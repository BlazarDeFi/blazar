{
  "language": "Solidity",
  "sources": {
    "contracts/AliceUSD.sol": {
      "content": "/*\nImplements ERC20 Token Standard: https://github.com/ethereum/EIPs/issues/20\nThis is a demo token that serves the purpose of being a stablecoin on the testnet\nto illustrate the mechanics of the IDA protocol.\n*/\n\npragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol';\n\ncontract AliceUSD is ERC20Mintable, ERC20Burnable {\n\n  string public name = \"Alice Demo USD\";\n  uint8 public decimals = 18;\n  string public symbol = \"AliceUSD\";\n  string public version = 'AUSD 1.0';\n\n  //A default amount that is minted every time someone request funds\n  //Implemented to impede easy attempts to publicly mint a large value of tokens\n  //and try to corrupt the system\n  uint256 constant public MINT_DEFAULT = 1000 ether;\n\n\n  /**\n   * @dev A function open for everyone to mint a small amount of test tokens\n   * to experiment with the IDA platform\n   */\n  function publicMint() public returns (bool) {\n    _mint(msg.sender, MINT_DEFAULT);\n    return true;\n  }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../Roles.sol\";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Destoys `amount` tokens from the caller.\n     *\n     * See `ERC20._burn`.\n     */\n    function burn(uint256 amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See `ERC20._burnFrom`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"
    },
    "contracts/ClaimsRegistry.sol": {
      "content": "pragma solidity ^0.5.2;\n\n/**\n * @title ClaimsRegistry\n * @dev This is based on the ERC-780 Ethereum Claims Registry (https://github.com/ethereum/EIPs/issues/780)\n * This implementation adds an ability to approve certain claims of fulfilled IDA promises by an additional entity in the most minimal form.\n * One claim could require multiple approvals.\n */\ncontract ClaimsRegistry {\n\n    mapping(address => mapping(address => mapping(bytes32 => bytes32))) public registry;\n\n    /**\n     * @dev An event that is emitted every time a claim is submitted by a service provider\n     * @param issuer  the service provider that is submitting the claim\n     * @param subject  the address of the IDA contract that is managing this type of impact promise\n     * @param key  a unique identifier (code) for an instance of impact promise\n     * @param value  an amount of money that is being unlocked when the impact promise is validated\n     * @param updatedAt  the timestamp when a claim was submitted\n     */\n    event ClaimSet(\n        address indexed issuer,\n        address indexed subject,\n        bytes32 indexed key,\n        bytes32 value,\n        uint updatedAt);\n\n\n    /**\n     * @dev An event that is emitted every time a claim is validated by a nominated validator\n     * @param approver  the Validator that verifies and signs off on the proof that an impact promise has been fulfilled\n     * @param issuer  the service provider that is submitting the claim\n     * @param subject  the address of the IDA contract that is managing this type of impact\n     * @param key  a unique identifier (code) for an instance of impact promise\n     * @param value  an amount of money that is being unlocked when the impact promise is validated\n     * @param approvedAt  the timestamp when a claim was approved\n     */\n    event ClaimApproved(\n        address approver,\n        address indexed issuer,\n        address indexed subject,\n        bytes32 indexed key,\n        bytes32 value,\n        uint approvedAt);\n\n\n    /**\n     * @dev An event that is emitted when a service provider decides to withdraw claim and cancel the validation procedure\n     * @param issuer  the service provider that is submitting the claim\n     * @param subject  the address of the IDA contract that is managing this type of impact\n     * @param key  a unique identifier (code) for an instance of impact promise\n     * @param removedAt  the timestamp when a claim was removed\n     */\n    event ClaimRemoved(\n        address indexed issuer,\n        address indexed subject,\n        bytes32 indexed key,\n        uint removedAt);\n\n\n    /**\n     * @dev A method that allows a service provider (msg.sender) to submit a claim with the following params:\n     *\n     * @param subject  the address of the IDA contract that is managing this type of impact\n     * @param key  a unique identifier (code) for an instance of impact promise\n     * @param value  the price of a claim\n     */\n    function setClaim(address subject, bytes32 key, bytes32 value) public {\n        registry[msg.sender][subject][key] = value;\n        emit ClaimSet(msg.sender, subject, key, value, now);\n    }\n\n\n    /**\n     * @dev A method to remove an existing claim. It could be used by a service provider to revoke a claim made\n     *      by mistake or one that is not ready to be validated.\n     *\n     * @param subject  the address of the IDA contract that is managing this type of impact\n     * @param key  a unique identifier (code) for an instance of impact promise\n     */\n    function removeClaim(address subject, bytes32 key) public {\n      require(getClaim(msg.sender, subject, key) != bytes32(0), \"Claim with given subject and key doesn't exist\");\n      delete registry[msg.sender][subject][key];\n\n      emit ClaimRemoved(msg.sender, subject, key, now);\n    }\n\n\n    /**\n     * @dev A method to validate an existing claim.\n     *\n     * @param subject  the address of the IDA contract that is managing this type of impact\n     * @param key  a unique identifier (code) for an instance of impact promise\n     */\n    function approveClaim(address issuer, address subject, bytes32 key) public {\n        bytes32 value = getClaim(issuer, subject, key);\n        require(value != bytes32(0), \"Claim with given subject and key doesn't exist\");\n\n        registry[msg.sender][subject][key] = value;\n        emit ClaimApproved(msg.sender, issuer, subject, key, value, now);\n    }\n\n\n    /**\n     * @dev Returns all of the details of the claim specified.\n     */\n    function getClaim(address issuer, address subject, bytes32 key) public view returns(bytes32) {\n      return registry[issuer][subject][key];\n    }\n\n\n    /**\n     * @dev Returns true if a claim with given subject and key was issued by the provided issuer\n     *      and validated by the provided approver.\n     */\n    function isApproved(address approver, address issuer, address subject, bytes32 key) public view returns(bool) {\n        return registry[issuer][subject][key] == registry[approver][subject][key];\n    }\n}\n"
    },
    "contracts/Escrow.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport 'openzeppelin-solidity/contracts/ownership/Ownable.sol';\n\n/**\n * @title Escrow\n * @dev Contract dedicated to holds funds that may be gradually unlocked to the recipient.\n *\n */\ncontract Escrow is Ownable {\n  using SafeMath for uint256;\n\n  event Unlocked(uint256 amount);\n  event Withdrawn(address indexed receiver, uint256 amount);\n\n  /**\n   * @dev Throws if called by any account other than the recipient.\n   */\n  modifier onlyRecipient() {\n    require(msg.sender == recipient, \"The caller is not the recipient\");\n    _;\n  }\n\n\n  ERC20 public paymentToken;\n  address public operator;\n  address public recipient;\n\n  uint256 public unlocked;\n  uint256 public withdrawn;\n  uint256 public refunded;\n  uint256 public capacity;\n\n  constructor(ERC20 _paymentToken, uint256 _capacity) public {\n    paymentToken = _paymentToken;\n    capacity = _capacity;\n  }\n\n\n  function setRecipient(address _recipient) public onlyOwner {\n    recipient = _recipient;\n  }\n\n\n  function unlock(uint256 _amount) public onlyOwner {\n    unlocked = unlocked.add(_amount);\n    require(unlocked <= capacity, \"Cannot unlock more than the max capacity of the escrow\");\n\n    emit Unlocked(_amount);\n  }\n\n\n  /**\n   * @dev Withdraw part of the escrow reserved for recipient\n   * @param _amount The amount of funds intended to be taken out\n   */\n  function withdraw(address _to, uint256 _amount) public onlyRecipient {\n    withdrawn = withdrawn.add(_amount);\n    require(withdrawn <= unlocked, \"Cannot withdraw more funds than has been unlocked\");\n\n    require(paymentToken.transfer(_to, _amount));\n\n    emit Withdrawn(msg.sender, _amount);\n  }\n\n  function refund(address _recipient, uint256 _amount) public onlyOwner {\n    refunded = refunded.add(_amount);\n    require(paymentToken.transfer(_recipient, _amount));\n  }\n\n  function funded() public view returns(uint256) {\n    return paymentToken.balanceOf(address(this)).add(withdrawn);\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/FluidEscrowFactory.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport './Escrow.sol';\nimport './FluidToken.sol';\n\n/**\n * @title Fluid Escrow Factory\n * @dev A special type of an escrow account that is linked to the payment rights token which represents\n * the right to redeem funds hold by an escrow.\n *\n */\ncontract FluidEscrowFactory {\n\n  event FluidTokenCreated(FluidToken token, Escrow escrow);\n\n  function createFluidEscrow(ERC20 _paymentToken, uint256 _capacity, address creator) public returns(Escrow) {\n    Escrow escrow = new Escrow(_paymentToken, _capacity);\n    FluidToken fluidToken = new FluidToken(escrow, _capacity);\n    escrow.setRecipient(address(fluidToken));\n    fluidToken.transfer(creator, _capacity);\n    escrow.transferOwnership(msg.sender);\n    emit FluidTokenCreated(fluidToken, escrow);\n    return escrow;\n  }\n\n}\n"
    },
    "contracts/FluidToken.sol": {
      "content": "/*\nThis is a new token type that gives the holder right to funds that may not yet be available.\nIt is based and compatible with the ERC20 token standard but has a double bottom line:\nfunds that are available for a holder and funds that have been already redeemed.\nBoth balances are automatically update when tokens are transferred making it fully tradable.\n*/\n\npragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport 'openzeppelin-solidity/contracts/math/Math.sol';\nimport './Escrow.sol';\n\ncontract FluidToken is ERC20 {\n  using SafeMath for uint256;\n\n\n  /**\n  * @dev Emitted when tokens are redeemed for funds locked in the escrow\n  */\n  event Redeemed(address indexed to, uint256 value);\n\n  /**\n  * @dev A pot holding funds that may be gradually filled and released to token holders.\n  */\n  Escrow public escrow;\n\n\n  /**\n  * @dev A core structure keeping an account of funds that have been already redeemed.\n  */\n  mapping (address => uint256) private _redeemed;\n\n\n  constructor(Escrow _escrow, uint256 _initialSupply) public {\n    escrow = Escrow(_escrow);\n    _mint(msg.sender, _initialSupply);\n  }\n\n  /**\n   * Can transfer non-zero amounts only.\n   * After the transfer we update both the token balance and the amount redeemed.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    uint256 redeemedProRata = amount.mul(_redeemed[sender]).div(balanceOf(sender));\n\n    _redeemed[sender] = _redeemed[sender].sub(redeemedProRata);\n    _redeemed[recipient] = _redeemed[recipient].add(redeemedProRata);\n\n    super._transfer(sender, recipient, amount);\n  }\n\n  function redeem(uint256 _amount) public {\n    uint256 available = getAvailableToRedeem();\n    require(_amount <= available, \"Cannot redeem more tokens than available\");\n\n    escrow.withdraw(msg.sender, _amount);\n    _redeemed[msg.sender] = _redeemed[msg.sender].add(_amount);\n    emit Redeemed(msg.sender, _amount);\n  }\n\n  function getRedeemed(address account) public view returns(uint256) {\n    return _redeemed[account];\n  }\n\n  function getAvailableToRedeem() public view returns(uint256) {\n    uint256 potential = Math.min(escrow.unlocked(), escrow.funded());\n    uint256 available = potential.mul(balanceOf(msg.sender)).sub(escrow.capacity().mul(_redeemed[msg.sender]));\n    available = available.div(escrow.capacity());\n    return available;\n  }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/math/Math.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/Ida.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport './Escrow.sol';\nimport './PaymentRights.sol';\nimport './ImpactPromise.sol';\nimport './ClaimsRegistry.sol';\n\n/**\n * @title Impact Delivery Agreement\n * @dev Contract to create flexible bounties with multiple actions to be completed (impact promises) and distributable reward payments.\n */\ncontract Ida {\n    using SafeMath for uint256;\n\n    event Created(address indexed creator, uint256 indexed promiseNumber, uint256 promisePrice, string name);\n    event Funded(address indexed funder, uint256 amount, uint256 totalFunded);\n    event Validated(uint256 amount);\n\n    /**\n     * @dev Throws if called by any account other than the Validator.\n     */\n    modifier onlyValidator() {\n        require(msg.sender == validator, \"The caller is not the validator\");\n        _;\n    }\n\n    ERC20 public paymentToken;\n    ImpactPromise public impactPromise;\n    PaymentRights public paymentRights;\n\n    Escrow public escrow;\n    ClaimsRegistry public claimsRegistry;\n\n    string public name;\n    uint256 public promiseNumber;\n    uint256 public validatedNumber;\n    uint256 public promisePrice;\n    address public validator;\n    uint256 public endTime;\n    address public serviceProvider;\n\n    constructor(\n      ERC20 _paymentToken,\n      ImpactPromise _impactPromise,\n      Escrow _escrow,\n      ClaimsRegistry _claimsRegistry,\n      string memory _name,\n      uint256 _promiseNumber,\n      uint256 _promisePrice,\n      address _validator,\n      uint256 _endTime,\n      address _serviceProvider\n    ) public {\n        require(address(_paymentToken) != address(0x0));\n        require(address(_impactPromise) != address(0x0));\n\n        name = _name;\n        paymentToken = _paymentToken;\n        impactPromise = _impactPromise;\n        claimsRegistry = _claimsRegistry;\n        promiseNumber = _promiseNumber;\n        promisePrice = _promisePrice;\n        validator = _validator;\n        endTime = _endTime;\n        serviceProvider = _serviceProvider;\n\n        escrow = _escrow;\n        paymentRights = PaymentRights(escrow.recipient());\n\n        emit Created(serviceProvider, promiseNumber, promisePrice, name);\n    }\n\n    /**\n    * @dev Allows people to fund the IDA with payments held in escrow until an impact promise is validated.\n    */\n    function fund(uint256 _amount) public {\n        require(!hasEnded());\n        require(paymentToken.balanceOf(address(escrow)).add(_amount) <= promisePrice.mul(promiseNumber), \"The funding amount exceeds allowed funding cap\");\n        paymentToken.transferFrom(msg.sender, address(escrow), _amount);\n        impactPromise.mint(msg.sender, _amount);\n\n        emit Funded(msg.sender, _amount, impactPromise.totalSupply());\n    }\n\n\n    function validatePromise(bytes32 key) public onlyValidator {\n        require(!hasEnded(), \"Cannot validate after project end\");\n        require(validatedNumber < promiseNumber, \"All the promises have already been validated\");\n        require(claimsRegistry.getClaim(serviceProvider, address(this), key) == bytes32(promisePrice), \"A claim must be registered before validation\");\n        require(!claimsRegistry.isApproved(validator, serviceProvider, address(this), key), \"This promise has already been validated\");\n\n        claimsRegistry.approveClaim(serviceProvider, address(this), key);\n        escrow.unlock(promisePrice);\n        validatedNumber = validatedNumber.add(1);\n        emit Validated(promisePrice);\n    }\n\n\n    function hasEnded() public view returns(bool) {\n      return now > endTime;\n    }\n\n\n    function getAvailableToRefund() public view returns(uint256) {\n      uint256 remaining = escrow.funded().sub(escrow.unlocked());\n      uint256 balance = impactPromise.balanceOf(msg.sender);\n      return balance == 0 ? 0 : remaining.mul(balance).div(impactPromise.totalSupply());\n    }\n\n\n    function refund() public {\n      require(hasEnded(), \"Refund is only available after the project has ended\");\n      uint256 refundable = getAvailableToRefund();\n      if (refundable > 0) {\n        impactPromise.burnAll(msg.sender);\n        escrow.refund(msg.sender, refundable);\n      }\n    }\n\n}\n"
    },
    "contracts/PaymentRights.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport './FluidToken.sol';\n\ncontract PaymentRights is FluidToken {\n\n  string public name = \"Payment Rights\";\n  uint8 public decimals = 18;\n  string public symbol = \"IDA-PR\";\n  string public version = '1.0';\n\n}\n"
    },
    "contracts/ImpactPromise.sol": {
      "content": "/*\nImplements ERC20 Token Standard: https://github.com/ethereum/EIPs/issues/20\n*/\n\npragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol';\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol';\n\ncontract ImpactPromise is ERC20Mintable, ERC20Burnable {\n\n    string public name = \"Impact Promise\";\n    uint8 public decimals = 18;\n    string public symbol = \"IDA-IP\";\n    string public version = '1.0';\n\n\n    function burnAll(address account) onlyMinter public {\n      _burn(account, balanceOf(account));\n    }\n\n\n}\n"
    },
    "contracts/IdaFactory.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport './Ida.sol';\nimport './SimpleTokenSeller.sol';\nimport './ImpactPromiseFactory.sol';\nimport './FluidEscrowFactory.sol';\n\n/**\n * @title IdaFactory - a contract designed to orchestrate Ida creation\n * by automatically deploying and linking payment rights seller contract\n *\n */\ncontract IdaFactory {\n  using SafeMath for uint256;\n\n  event IdaCreated(address indexed ida);\n\n  ImpactPromiseFactory impactPromiseFactory;\n  FluidEscrowFactory fluidEscrowFactory;\n  ClaimsRegistry public claimsRegistry;\n  SimpleTokenSeller public simpleTokenSeller;\n\n\n  constructor(SimpleTokenSellerFactory _stsFactory, ImpactPromiseFactory _impactPromiseFactory, FluidEscrowFactory _fluidEscrowFactory, ClaimsRegistry _claimsRegistry) public {\n    simpleTokenSeller = _stsFactory.createSimpleTokenSeller();\n    impactPromiseFactory = _impactPromiseFactory;\n    fluidEscrowFactory = _fluidEscrowFactory;\n    claimsRegistry = _claimsRegistry;\n  }\n\n\n  function createIda(\n    ERC20 _paymentToken,\n    string memory _name,\n    uint256 _outcomesNumber,\n    uint256 _outcomesPrice,\n    address _validator,\n    uint256 _endTime\n  ) public returns (Ida) {\n\n    ImpactPromise promiseToken = impactPromiseFactory.createImpactPromise();\n    Escrow escrow = fluidEscrowFactory.createFluidEscrow(_paymentToken, _outcomesPrice.mul(_outcomesNumber), msg.sender);\n    Ida ida = new Ida(_paymentToken, promiseToken, escrow, claimsRegistry, _name, _outcomesNumber, _outcomesPrice, _validator, _endTime, msg.sender);\n    escrow.transferOwnership(address(ida));\n    promiseToken.addMinter(address(ida));\n    simpleTokenSeller.addMarket(msg.sender, PaymentRights(escrow.recipient()), _paymentToken);\n    emit IdaCreated(address(ida));\n    return ida;\n  }\n\n}\n"
    },
    "contracts/SimpleTokenSeller.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/ownership/Ownable.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport './PaymentRights.sol';\n\n/**\n * @title SimpleSeller - a contract designed to orchestrate IDA creation\n * by automatically deploying and linking payment rights seller contract\n *\n */\ncontract SimpleTokenSeller {\n  using SafeMath for uint256;\n\n  event MarketAdded(address indexed operator, PaymentRights offeredToken, ERC20 indexed paymentToken);\n  event TokensSold(address indexed operator, PaymentRights indexed offeredToken, ERC20 indexed paymentToken, uint256 amountSold, uint256 discount);\n  event ConditionsUpdated(address indexed operator, PaymentRights indexed offeredToken, uint256 amountAvailable, uint256 discount);\n\n  uint256 public constant FULL_PERCENTAGE = 100;\n\n  struct Market {\n    ERC20 paymentToken;\n    PaymentRights offeredToken;\n    uint256 supply;\n    uint256 discount;\n  }\n\n  mapping (address => Market) public markets;\n\n  function addMarket(address _operator, PaymentRights _offeredToken, ERC20 _paymentToken) public {\n    markets[_operator] = Market(_paymentToken, _offeredToken, 0, 0);\n    emit MarketAdded(_operator, _offeredToken, _paymentToken);\n  }\n\n  function updateConditions(uint256 supply, uint256 discount) public {\n    Market storage market = markets[msg.sender];\n    require(address(market.paymentToken) != address(0), \"There is no market defined for a given operator\");\n\n    require(market.supply <= market.offeredToken.balanceOf(msg.sender).add(market.supply),\n      \"Cannot set supply greater than the amount of tokens available\");\n    require(market.discount < FULL_PERCENTAGE, \"Discount must be less than 100%\");\n\n    //Unlock unsold tokens\n    if (market.supply > 0) {\n      market.offeredToken.transfer(msg.sender, market.supply);\n    }\n\n    market.supply = supply;\n    market.discount = discount;\n\n    //Lock offered tokens under this contract\n    market.offeredToken.transferFrom(msg.sender, address(this), supply);\n\n    emit ConditionsUpdated(msg.sender, market.offeredToken, market.supply, market.discount);\n  }\n\n  function buy(address operator, uint256 amount) public {\n    Market storage market = markets[operator];\n    require(address(market.paymentToken) != address(0), \"There is no market defined for a given Ida\");\n\n    require(amount > 0);\n    require(amount <= market.supply);\n\n    uint256 price = getEffectivePrice(operator, amount);\n    market.supply = market.supply.sub(amount);\n\n    market.offeredToken.transfer(msg.sender, amount);\n    market.paymentToken.transferFrom(msg.sender, operator, price);\n\n    emit TokensSold(msg.sender, market.offeredToken, market.paymentToken, amount, market.discount);\n    emit ConditionsUpdated(msg.sender, market.offeredToken, market.supply, market.discount);\n  }\n\n  function getEffectivePrice(address operator, uint256 amount) public view returns(uint256) {\n    Market storage market = markets[operator];\n    require(address(market.paymentToken) != address(0), \"There is no market defined for a given Ida\");\n\n    uint256 unRedeemed = market.offeredToken.balanceOf(address(this)).sub(market.offeredToken.getRedeemed(address(this)));\n    uint256 unRedeemedAmount = unRedeemed.mul(amount).div(market.offeredToken.balanceOf(address(this)));\n\n    return FULL_PERCENTAGE.sub(market.discount).mul(unRedeemedAmount).div(FULL_PERCENTAGE);\n  }\n\n  function getSupply(address operator) public view returns(uint256) {\n    Market storage market = markets[operator];\n    require(address(market.paymentToken) != address(0), \"There is no market defined for a given Ida\");\n\n    return market.supply;\n  }\n\n  function getDiscount(address operator) public view returns(uint256) {\n    Market storage market = markets[operator];\n    require(address(market.paymentToken) != address(0), \"There is no market defined for a given Ida\");\n\n    return market.discount;\n  }\n\n}\n\ncontract SimpleTokenSellerFactory {\n\n  function createSimpleTokenSeller() public returns (SimpleTokenSeller) {\n    return new SimpleTokenSeller();\n  }\n\n}\n"
    },
    "contracts/ImpactPromiseFactory.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport './ImpactPromise.sol';\n\n/**\n * @title ImpactPromiseFactory - a helper contract orchestrating the creation\n * of dedicated ImpactPromise tokens for each new IDA\n */\ncontract ImpactPromiseFactory {\n\n  function createImpactPromise() public returns (ImpactPromise) {\n    ImpactPromise ip = new ImpactPromise();\n    ip.addMinter(msg.sender);\n    return ip;\n  }\n\n}\n"
    },
    "contracts/IdaMock.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport './Ida.sol';\n\n/**\n * @title Impact Delivery Agreement Mock\n * @dev Allows testing the end refunds\n *\n */\ncontract IdaMock is Ida {\n\n  bool mockEnded;\n\n  constructor(\n    ERC20 _paymentToken,\n    ImpactPromise _impactPromise,\n    Escrow _escrow,\n    ClaimsRegistry _claimsRegistry,\n    string memory _name,\n    uint256 _outcomesNumber,\n    uint256 _outcomesPrice,\n    address _validator,\n    uint256 _endTime,\n    address _serviceProvider\n  ) public\n  Ida(_paymentToken, _impactPromise, _escrow, _claimsRegistry, _name, _outcomesNumber, _outcomesPrice, _validator, _endTime, _serviceProvider) {\n  }\n\n  function setEnd() public {\n    mockEnded = true;\n  }\n\n\n  function hasEnded() public view returns(bool) {\n    return mockEnded;\n  }\n\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity >=0.4.21 <0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/RefundableEscrow.sol": {
      "content": "pragma solidity ^0.5.2;\n\nimport 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport './Escrow.sol';\n\n/**\n * @title RefundableEscrow\n * @dev An extension to the Escrow contract that allows the owner to withdraw\n * the funds that haven't been yet unlocked.\n *\n */\ncontract RefundableEscrow is Escrow {\n  using SafeMath for uint256;\n\n  event Refunded(address recipient, uint amount);\n\n  uint256 public refunded;\n\n  constructor(ERC20 _paymentToken, uint256 _capacity) public\n  Escrow(_paymentToken, _capacity) { }\n\n  function refund(address _recipient, uint256 _amount) public onlyOwner {\n    uint256 committed = unlocked.sub(withdrawn);\n    uint256 available = paymentToken.balanceOf(address(this)).sub(committed);\n    require(_amount <= available, \"Cannot refund more than is available\");\n\n    refunded = refunded.add(_amount);\n    require(paymentToken.transfer(_recipient, _amount));\n\n    emit Refunded(_recipient, _amount);\n  }\n\n  function funded() public view returns(uint256) {\n    return paymentToken.balanceOf(address(this)).add(withdrawn).add(refunded);\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}