{
  "language": "Solidity",
  "sources": {
    "contracts/aave/configuration/AddressStorage.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract AddressStorage {\n    mapping(bytes32 => address) private addresses;\n\n    function getAddress(bytes32 _key) public view returns (address) {\n        return addresses[_key];\n    }\n\n    function _setAddress(bytes32 _key, address _value) internal {\n        addresses[_key] = _value;\n    }\n\n}\n"
    },
    "contracts/aave/configuration/LendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"../libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol\";\n\nimport \"./AddressStorage.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\n\n/**\n* @title LendingPoolAddressesProvider contract\n* @notice Is the main registry of the protocol. All the different components of the protocol are accessible\n* through the addresses provider.\n* @author Aave\n**/\n\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\n    //events\n    event LendingPoolUpdated(address indexed newAddress);\n    event LendingPoolCoreUpdated(address indexed newAddress);\n    event LendingPoolParametersProviderUpdated(address indexed newAddress);\n    event LendingPoolManagerUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\n    event LendingPoolDataProviderUpdated(address indexed newAddress);\n    event EthereumAddressUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event FeeProviderUpdated(address indexed newAddress);\n    event TokenDistributorUpdated(address indexed newAddress);\n\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n\n    bytes32 private constant LENDING_POOL = \"LENDING_POOL\";\n    bytes32 private constant LENDING_POOL_CORE = \"LENDING_POOL_CORE\";\n    bytes32 private constant LENDING_POOL_CONFIGURATOR = \"LENDING_POOL_CONFIGURATOR\";\n    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = \"PARAMETERS_PROVIDER\";\n    bytes32 private constant LENDING_POOL_MANAGER = \"LENDING_POOL_MANAGER\";\n    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\n    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = \"FLASHLOAN_PROVIDER\";\n    bytes32 private constant DATA_PROVIDER = \"DATA_PROVIDER\";\n    bytes32 private constant ETHEREUM_ADDRESS = \"ETHEREUM_ADDRESS\";\n    bytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\n    bytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\n    bytes32 private constant FEE_PROVIDER = \"FEE_PROVIDER\";\n    bytes32 private constant WALLET_BALANCE_PROVIDER = \"WALLET_BALANCE_PROVIDER\";\n    bytes32 private constant TOKEN_DISTRIBUTOR = \"TOKEN_DISTRIBUTOR\";\n\n\n    /**\n    * @dev returns the address of the LendingPool proxy\n    * @return the lending pool proxy address\n    **/\n    function getLendingPool() public view returns (address) {\n        return getAddress(LENDING_POOL);\n    }\n\n\n    /**\n    * @dev updates the implementation of the lending pool\n    * @param _pool the new lending pool implementation\n    **/\n    function setLendingPoolImpl(address _pool) public onlyOwner {\n        updateImplInternal(LENDING_POOL, _pool);\n        emit LendingPoolUpdated(_pool);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolCore proxy\n    * @return the lending pool core proxy address\n     */\n    function getLendingPoolCore() public view returns (address payable) {\n        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\n        return core;\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool core\n    * @param _lendingPoolCore the new lending pool core implementation\n    **/\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\n        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\n        emit LendingPoolCoreUpdated(_lendingPoolCore);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolConfigurator proxy\n    * @return the lending pool configurator proxy address\n    **/\n    function getLendingPoolConfigurator() public view returns (address) {\n        return getAddress(LENDING_POOL_CONFIGURATOR);\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool configurator\n    * @param _configurator the new lending pool configurator implementation\n    **/\n    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\n        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\n        emit LendingPoolConfiguratorUpdated(_configurator);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolDataProvider proxy\n    * @return the lending pool data provider proxy address\n     */\n    function getLendingPoolDataProvider() public view returns (address) {\n        return getAddress(DATA_PROVIDER);\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool data provider\n    * @param _provider the new lending pool data provider implementation\n    **/\n    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\n        updateImplInternal(DATA_PROVIDER, _provider);\n        emit LendingPoolDataProviderUpdated(_provider);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolParametersProvider proxy\n    * @return the address of the Lending pool parameters provider proxy\n    **/\n    function getLendingPoolParametersProvider() public view returns (address) {\n        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\n    }\n\n    /**\n    * @dev updates the implementation of the lending pool parameters provider\n    * @param _parametersProvider the new lending pool parameters provider implementation\n    **/\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\n        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\n        emit LendingPoolParametersProviderUpdated(_parametersProvider);\n    }\n\n    /**\n    * @dev returns the address of the FeeProvider proxy\n    * @return the address of the Fee provider proxy\n    **/\n    function getFeeProvider() public view returns (address) {\n        return getAddress(FEE_PROVIDER);\n    }\n\n    /**\n    * @dev updates the implementation of the FeeProvider proxy\n    * @param _feeProvider the new lending pool fee provider implementation\n    **/\n    function setFeeProviderImpl(address _feeProvider) public onlyOwner {\n        updateImplInternal(FEE_PROVIDER, _feeProvider);\n        emit FeeProviderUpdated(_feeProvider);\n    }\n\n    /**\n    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\n    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\n    * the addresses are changed directly.\n    * @return the address of the Lending pool liquidation manager\n    **/\n\n    function getLendingPoolLiquidationManager() public view returns (address) {\n        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\n    }\n\n    /**\n    * @dev updates the address of the Lending pool liquidation manager\n    * @param _manager the new lending pool liquidation manager address\n    **/\n    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\n        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\n        emit LendingPoolLiquidationManagerUpdated(_manager);\n    }\n\n    /**\n    * @dev the functions below are storing specific addresses that are outside the context of the protocol\n    * hence the upgradable proxy pattern is not used\n    **/\n\n\n    function getLendingPoolManager() public view returns (address) {\n        return getAddress(LENDING_POOL_MANAGER);\n    }\n\n    function setLendingPoolManager(address _lendingPoolManager) public onlyOwner {\n        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\n        emit LendingPoolManagerUpdated(_lendingPoolManager);\n    }\n\n    function getPriceOracle() public view returns (address) {\n        return getAddress(PRICE_ORACLE);\n    }\n\n    function setPriceOracle(address _priceOracle) public onlyOwner {\n        _setAddress(PRICE_ORACLE, _priceOracle);\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    function getLendingRateOracle() public view returns (address) {\n        return getAddress(LENDING_RATE_ORACLE);\n    }\n\n    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\n        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\n        emit LendingRateOracleUpdated(_lendingRateOracle);\n    }\n\n\n    function getTokenDistributor() public view returns (address) {\n        return getAddress(TOKEN_DISTRIBUTOR);\n    }\n\n    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\n        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\n        emit TokenDistributorUpdated(_tokenDistributor);\n    }\n\n\n    /**\n    * @dev internal function to update the implementation of a specific component of the protocol\n    * @param _id the id of the contract to be updated\n    * @param _newAddress the address of the new implementation\n    **/\n    function updateImplInternal(bytes32 _id, address _newAddress) internal {\n        address payable proxyAddress = address(uint160(getAddress(_id)));\n\n        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\n        bytes memory params = abi.encodeWithSignature(\"initialize(address)\", address(this));\n\n        if (proxyAddress == address(0)) {\n            proxy = new InitializableAdminUpgradeabilityProxy();\n            proxy.initialize(_newAddress, address(this), params);\n            _setAddress(_id, address(proxy));\n            emit ProxyCreated(_id, address(proxy));\n        } else {\n            proxy.upgradeToAndCall(_newAddress, params);\n        }\n\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\nimport \"./InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n    /**\n   * Contract initializer.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    function initialize(address _logic, address _admin, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n   * @return The address of the proxy admin.\n   */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n   * @return The address of the implementation.\n   */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n   * @return The admin slot.\n   */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        //solium-disable-next-line\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n    function _setAdmin(address newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n        //solium-disable-next-line\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n    function _willFallback() internal {\n        require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n        super._willFallback();\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/UpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Proxy.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n    /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n    event Upgraded(address indexed implementation);\n\n    /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        //solium-disable-next-line\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        //solium-disable-next-line\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/Proxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n    /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n    function() external payable {\n        _fallback();\n    }\n\n    /**\n   * @return The Address of the implementation.\n   */\n    function _implementation() internal view returns (address);\n\n    /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n    function _delegate(address implementation) internal {\n        //solium-disable-next-line\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n\n    /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n    function _willFallback() internal {}\n\n    /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * > It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n   * @dev Contract initializer.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    function initialize(address _logic, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/aave/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n@title ILendingPoolAddressesProvider interface\n@notice provides the interface to fetch the LendingPoolCore address\n */\n\ncontract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public view returns (address);\n    function setLendingPoolImpl(address _pool) public;\n\n    function getLendingPoolCore() public view returns (address payable);\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\n\n    function getLendingPoolConfigurator() public view returns (address);\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\n\n    function getLendingPoolDataProvider() public view returns (address);\n    function setLendingPoolDataProviderImpl(address _provider) public;\n\n    function getLendingPoolParametersProvider() public view returns (address);\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\n\n    function getTokenDistributor() public view returns (address);\n    function setTokenDistributor(address _tokenDistributor) public;\n\n\n    function getFeeProvider() public view returns (address);\n    function setFeeProviderImpl(address _feeProvider) public;\n\n    function getLendingPoolLiquidationManager() public view returns (address);\n    function setLendingPoolLiquidationManager(address _manager) public;\n\n    function getLendingPoolManager() public view returns (address);\n    function setLendingPoolManager(address _lendingPoolManager) public;\n\n    function getPriceOracle() public view returns (address);\n    function setPriceOracle(address _priceOracle) public;\n\n    function getLendingRateOracle() public view returns (address);\n    function setLendingRateOracle(address _lendingRateOracle) public;\n\n}"
    },
    "contracts/aave/configuration/LendingPoolParametersProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\nimport \"./UintStorage.sol\";\n\n/**\n* @title LendingPoolParametersProvider\n* @author Aave\n* @notice stores the configuration parameters of the Lending Pool contract\n**/\n\ncontract LendingPoolParametersProvider is VersionedInitializable {\n\n    uint256 private constant MAX_STABLE_RATE_BORROW_SIZE_PERCENT = 25;\n    uint256 private constant REBALANCE_DOWN_RATE_DELTA = (1e27)/5;\n    uint256 private constant FLASHLOAN_FEE_TOTAL = 35;\n    uint256 private constant FLASHLOAN_FEE_PROTOCOL = 3000;\n\n    uint256 constant private DATA_PROVIDER_REVISION = 0x1;\n\n    function getRevision() internal pure returns(uint256) {\n        return DATA_PROVIDER_REVISION;\n    }\n\n    /**\n    * @dev initializes the LendingPoolParametersProvider after it's added to the proxy\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider\n    */\n    function initialize(address _addressesProvider) public initializer {\n    }\n    /**\n    * @dev returns the maximum stable rate borrow size, in percentage of the available liquidity.\n    **/\n    function getMaxStableRateBorrowSizePercent() external pure returns (uint256)  {\n        return MAX_STABLE_RATE_BORROW_SIZE_PERCENT;\n    }\n\n    /**\n    * @dev returns the delta between the current stable rate and the user stable rate at\n    *      which the borrow position of the user will be rebalanced (scaled down)\n    **/\n    function getRebalanceDownRateDelta() external pure returns (uint256) {\n        return REBALANCE_DOWN_RATE_DELTA;\n    }\n\n    /**\n    * @dev returns the fee applied to a flashloan and the portion to redirect to the protocol, in basis points.\n    **/\n    function getFlashLoanFeesInBips() external pure returns (uint256, uint256) {\n        return (FLASHLOAN_FEE_TOTAL, FLASHLOAN_FEE_PROTOCOL);\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/VersionedInitializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.6.0;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\ncontract VersionedInitializable {\n    /**\n   * @dev Indicates that the contract has been initialized.\n   */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n    bool private initializing;\n\n    /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            lastInitializedRevision = revision;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev returns the revision number of the contract.\n    /// Needs to be defined in the inherited class as a constant.\n    function getRevision() internal pure returns(uint256);\n\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/aave/configuration/UintStorage.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract UintStorage {\n    mapping(bytes32 => uint256) private uints;\n\n    function getUint(bytes32 _key) public view returns (uint256) {\n        return uints[_key];\n    }\n\n    function _setUint(bytes32 _key, uint256 _value) internal {\n        uints[_key] = _value;\n    }\n\n}\n"
    },
    "contracts/aave/fees/FeeProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\nimport \"../interfaces/IFeeProvider.sol\";\nimport \"../libraries/WadRayMath.sol\";\n\n\n/**\n* @title FeeProvider contract\n* @notice Implements calculation for the fees applied by the protocol\n* @author Aave\n**/\ncontract FeeProvider is IFeeProvider, VersionedInitializable {\n    using WadRayMath for uint256;\n\n    // percentage of the fee to be calculated on the loan amount\n    uint256 public originationFeePercentage;\n\n\n    uint256 constant public FEE_PROVIDER_REVISION = 0x1;\n\n    function getRevision() internal pure returns(uint256) {\n        return FEE_PROVIDER_REVISION;\n    }\n    /**\n    * @dev initializes the FeeProvider after it's added to the proxy\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider\n    */\n    function initialize(address _addressesProvider) public initializer {\n        /// @notice origination fee is set as default as 25 basis points of the loan amount (0.0025%)\n        originationFeePercentage = 0.0025 * 1e18;\n    }\n\n    /**\n    * @dev calculates the origination fee for every loan executed on the platform.\n    * @param _user can be used in the future to apply discount to the origination fee based on the\n    * _user account (eg. stake AAVE tokens in the lending pool, or deposit > 1M USD etc.)\n    * @param _amount the amount of the loan\n    **/\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256) {\n        return _amount.wadMul(originationFeePercentage);\n    }\n\n    /**\n    * @dev returns the origination fee percentage\n    **/\n    function getLoanOriginationFeePercentage() external view returns (uint256) {\n        return originationFeePercentage;\n    }\n\n}\n"
    },
    "contracts/aave/interfaces/IFeeProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/************\n@title IFeeProvider interface\n@notice Interface for the Aave fee provider.\n*/\n\ninterface IFeeProvider {\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256);\n    function getLoanOriginationFeePercentage() external view returns (uint256);\n}\n"
    },
    "contracts/aave/libraries/WadRayMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\n\nlibrary WadRayMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant halfWAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant halfRAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    function ray() internal pure returns (uint256) {\n        return RAY;\n    }\n    function wad() internal pure returns (uint256) {\n        return WAD;\n    }\n\n    function halfRay() internal pure returns (uint256) {\n        return halfRAY;\n    }\n\n    function halfWad() internal pure returns (uint256) {\n        return halfWAD;\n    }\n\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfWAD.add(a.mul(b)).div(WAD);\n    }\n\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(WAD)).div(b);\n    }\n\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return halfRAY.add(a.mul(b)).div(RAY);\n    }\n\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        return halfB.add(a.mul(RAY)).div(b);\n    }\n\n    function rayToWad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\n\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\n    }\n\n    function wadToRay(uint256 a) internal pure returns (uint256) {\n        return a.mul(WAD_RAY_RATIO);\n    }\n\n    /**\n    * @dev calculates base^exp. The code uses the ModExp precompile\n    * @return base^exp, in ray\n    */\n    //solium-disable-next-line\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rayMul(x, x);\n\n            if (n % 2 != 0) {\n                z = rayMul(z, x);\n            }\n        }\n    }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "contracts/aave/fees/TokenDistributor.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\n\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\nimport \"../interfaces/IKyberNetworkProxyInterface.sol\";\nimport \"../libraries/EthAddressLib.sol\";\n\n\n/// @title TokenDistributor\n/// @author Aave\n/// @notice Receives tokens and manages the distribution amongst receivers\n///  The usage is as follows:\n///  - The distribution addresses and percentages are set up on construction\n///  - The Kyber Proxy is approved for a list of tokens in construction, which will be later burnt\n///  - At any moment, anyone can call distribute() with a list of token addresses in order to distribute\n///    the accumulated token amounts and/or ETH in this contract to all the receivers with percentages\n///  - If the address(0) is used as receiver, this contract will trade in Kyber to tokenToBurn (LEND)\n///    and burn it (sending to address(0) the tokenToBurn)\ncontract TokenDistributor is VersionedInitializable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct Distribution {\n        address[] receivers;\n        uint256[] percentages;\n    }\n\n    event DistributionUpdated(address[] receivers, uint256[] percentages);\n    event Distributed(address receiver, uint256 percentage, uint256 amount);\n    event Setup(address tokenToBurn, address kyberProxy, address _recipientBurn);\n    event Trade(address indexed from, uint256 fromAmount, uint256 toAmount);\n    event Burn(uint256 amount);\n\n    uint256 public constant IMPLEMENTATION_REVISION = 0x1;\n\n    uint256 public constant MAX_UINT = 2**256 - 1;\n\n    uint256 public constant MAX_UINT_MINUS_ONE = (2**256 - 1) - 1;\n\n    /// @notice A value of 1 will execute the trade according to market price in the time of the transaction confirmation\n    uint256 public constant MIN_CONVERSION_RATE = 1;\n\n    address public constant KYBER_ETH_MOCK_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n\n    /// @notice Defines how tokens and ETH are distributed on each call to .distribute()\n    Distribution private distribution;\n\n    /// @notice Instead of using 100 for percentages, higher base to have more precision in the distribution\n    uint256 public constant DISTRIBUTION_BASE = 10000;\n\n    /// @notice Kyber Proxy contract to trade tokens/ETH to tokenToBurn\n    IKyberNetworkProxyInterface public kyberProxy;\n\n    /// @notice The address of the token to burn (LEND token)\n    address public tokenToBurn;\n\n    /// @notice Address to send tokens to \"burn\".\n    /// Because of limitations on OZ ERC20, on dev it's needed to use the 0x00000...1 address instead of address(0)\n    /// So this param needs to be received on construction\n    address public recipientBurn;\n\n    /// @notice Called by the proxy when setting this contract as implementation\n    function initialize(\n        address _recipientBurn,\n        address _tokenToBurn,\n        address _kyberProxy,\n        address[] memory _receivers,\n        uint256[] memory _percentages,\n        IERC20[] memory _tokens\n    ) public initializer {\n        recipientBurn = _recipientBurn;\n        tokenToBurn = _tokenToBurn;\n        kyberProxy = IKyberNetworkProxyInterface(_kyberProxy);\n        internalSetTokenDistribution(_receivers, _percentages);\n        approveKyber(_tokens);\n        emit Setup(_tokenToBurn, _kyberProxy, _recipientBurn);\n    }\n\n    /// @notice In order to receive ETH transfers\n    function() external payable {}\n\n    /// @notice Distributes a list of _tokens balances in this contract, depending on the distribution\n    /// @param _tokens list of ERC20 tokens to distribute\n    function distribute(IERC20[] memory _tokens) public {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _tokenAddress = address(_tokens[i]);\n            uint256 _balanceToDistribute = (_tokenAddress != EthAddressLib.ethAddress())\n                ? _tokens[i].balanceOf(address(this))\n                : address(this).balance;\n            if (_balanceToDistribute <= 0) {\n                continue;\n            }\n\n            Distribution memory _distribution = distribution;\n            for (uint256 j = 0; j < _distribution.receivers.length; j++) {\n                uint256 _amount = _balanceToDistribute.mul(_distribution.percentages[j]).div(DISTRIBUTION_BASE);\n                if (_distribution.receivers[j] != address(0)) {\n                    if (_tokenAddress != EthAddressLib.ethAddress()) {\n                        _tokens[i].safeTransfer(_distribution.receivers[j], _amount);\n                    } else {\n                        (bool _success,) = _distribution.receivers[j].call.value(_amount)(\"\");\n                        require(_success, \"Reverted ETH transfer\");\n                    }\n                    emit Distributed(_distribution.receivers[j], _distribution.percentages[j], _amount);\n                } else {\n                    uint256 _amountToBurn = _amount;\n                    // If the token to burn is already tokenToBurn, we don't trade, burning directly\n                    if (_tokenAddress != tokenToBurn) {\n                        _amountToBurn = internalTrade(_tokenAddress, _amount);\n                    }\n                    internalBurn(_amountToBurn);\n                }\n            }\n        }\n    }\n\n    /// @notice \"Infinite\" approval for all the tokens initialized\n    /// @param _tokens List of IERC20 to approve\n    function approveKyber(IERC20[] memory _tokens) public {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (address(_tokens[i]) != EthAddressLib.ethAddress()) {\n                _tokens[i].safeApprove(address(kyberProxy), MAX_UINT_MINUS_ONE);\n            }\n        }\n    }\n\n    /// @notice Returns the receivers and percentages of the contract Distribution\n    /// @return receivers array of addresses and percentages array on uints\n    function getDistribution() public view returns(address[] memory receivers, uint256[] memory percentages) {\n        receivers = distribution.receivers;\n        percentages = distribution.percentages;\n    }\n\n    /// @notice Gets the revision number of the contract\n    /// @return The revision numeric reference\n    function getRevision() internal pure returns (uint256) {\n        return IMPLEMENTATION_REVISION;\n    }\n\n    /// @notice Sets _receivers addresses with _percentages for each one\n    /// @param _receivers Array of addresses receiving a percentage of the distribution, both user addresses\n    ///   or contracts\n    /// @param _percentages Array of percentages each _receivers member will get\n    function internalSetTokenDistribution(address[] memory _receivers, uint256[] memory _percentages) internal {\n        require(_receivers.length == _percentages.length, \"Array lengths should be equal\");\n\n        distribution = Distribution({receivers: _receivers, percentages: _percentages});\n        emit DistributionUpdated(_receivers, _percentages);\n    }\n\n    /// @notice Internal trade function\n    /// @param _from The token to trade from\n    /// @param _amount The amount to trade\n    function internalTrade(address _from, uint256 _amount) internal returns(uint256) {\n        address _kyberFromRef = (_from == EthAddressLib.ethAddress())\n            ? KYBER_ETH_MOCK_ADDRESS\n            : _from;\n        uint256 _value = (_from == EthAddressLib.ethAddress())\n            ? _amount\n            : 0;\n\n        uint256 _amountReceived = kyberProxy.tradeWithHint.value(_value)(\n            // _from token (or ETH mock address)\n            IERC20(_kyberFromRef),\n            // amount of the _from token to trade\n            _amount,\n            // _to token (or ETH mock address)\n            IERC20(tokenToBurn),\n            // address which will receive the _to token amount traded\n            address(this),\n            // max amount to receive, no limit, using the max uint\n            MAX_UINT,\n            // conversion rate, use 1 for market price\n            MIN_CONVERSION_RATE,\n            // Related with a referral program, not needed\n            0x0000000000000000000000000000000000000000,\n            // Related with filtering of reserves by permisionless or not. Not needed\n            \"\"\n        );\n        emit Trade(_kyberFromRef, _amount, _amountReceived);\n        return _amountReceived;\n    }\n\n    /// @notice Internal function to send _amount of tokenToBurn to the 0x0 address\n    /// @param _amount The amount to burn\n    function internalBurn(uint256 _amount) internal {\n        require(IERC20(tokenToBurn).transfer(recipientBurn, _amount), \"INTERNAL_BURN. Reverted transfer to recipientBurn address\");\n        emit Burn(_amount);\n    }\n\n}"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Destoys `amount` tokens from the caller.\n     *\n     * See `ERC20._burn`.\n     */\n    function burn(uint256 amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See `ERC20._burnFrom`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"
    },
    "contracts/aave/interfaces/IKyberNetworkProxyInterface.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKyberNetworkProxyInterface {\n    function maxGasPrice() external view returns(uint);\n    function getUserCapInWei(address user) external view returns(uint);\n    function getUserCapInTokenWei(address user, IERC20 token) external view returns(uint);\n    function enabled() external view returns(bool);\n    function info(bytes32 id) external view returns(uint);\n    function getExpectedRate(IERC20 src, IERC20 dest, uint srcQty)\n        external view returns (uint expectedRate, uint slippageRate);\n    function tradeWithHint(\n        IERC20 src,\n        uint srcAmount,\n        IERC20 dest,\n        address destAddress,\n        uint maxDestAmount,\n        uint minConversionRate,\n        address walletId,\n        bytes calldata hint) external payable returns(uint);\n}"
    },
    "contracts/aave/libraries/EthAddressLib.sol": {
      "content": "pragma solidity ^0.5.0;\n\nlibrary EthAddressLib {\n\n    /**\n    * @dev returns the address used within the protocol to identify ETH\n    * @return the address assigned to ETH\n     */\n    function ethAddress() internal pure returns(address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}"
    },
    "contracts/aave/flashloan/base/FlashLoanReceiverBase.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IFlashLoanReceiver.sol\";\nimport \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../../libraries/EthAddressLib.sol\";\n\ncontract FlashLoanReceiverBase is IFlashLoanReceiver {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    ILendingPoolAddressesProvider public addressesProvider;\n\n    constructor(ILendingPoolAddressesProvider _provider) public {\n        addressesProvider = _provider;\n    }\n\n    function () external payable {\n    }\n\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\n\n        address payable core = addressesProvider.getLendingPoolCore();\n\n        transferInternal(core,_reserve, _amount);\n    }\n\n    function transferInternal(address payable _destination, address _reserve, uint256  _amount) internal {\n        if(_reserve == EthAddressLib.ethAddress()) {\n            //solium-disable-next-line\n            _destination.call.value(_amount)(\"\");\n            return;\n        }\n\n        IERC20(_reserve).safeTransfer(_destination, _amount);\n\n\n    }\n\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\n        if(_reserve == EthAddressLib.ethAddress()) {\n\n            return _target.balance;\n        }\n\n        return IERC20(_reserve).balanceOf(_target);\n\n    }\n}"
    },
    "contracts/aave/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n* @title IFlashLoanReceiver interface\n* @notice Interface for the Aave fee IFlashLoanReceiver.\n* @author Aave\n* @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n**/\ninterface IFlashLoanReceiver {\n\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\n}\n"
    },
    "contracts/aave/interfaces/IChainlinkAggregator.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface IChainlinkAggregator {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\n}"
    },
    "contracts/aave/interfaces/ILendingRateOracle.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n* @title ILendingRateOracle interface\n* @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\n**/\n\ninterface ILendingRateOracle {\n    /**\n    @dev returns the market borrow rate in ray\n    **/\n    function getMarketBorrowRate(address _asset) external view returns (uint256);\n\n    /**\n    @dev sets the market borrow rate. Rate value must be in ray\n    **/\n    function setMarketBorrowRate(address _asset, uint256 _rate) external;\n}\n"
    },
    "contracts/aave/interfaces/IPriceOracle.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/************\n@title IPriceOracle interface\n@notice Interface for the Aave price oracle.*/\ninterface IPriceOracle {\n    /***********\n    @dev returns the asset price in ETH\n     */\n    function getAssetPrice(address _asset) external view returns (uint256);\n\n    /***********\n    @dev sets the asset price, in wei\n     */\n    function setAssetPrice(address _asset, uint256 _price) external;\n\n}\n"
    },
    "contracts/aave/interfaces/IPriceOracleGetter.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/************\n@title IPriceOracleGetter interface\n@notice Interface for the Aave price oracle.*/\ninterface IPriceOracleGetter {\n    /***********\n    @dev returns the asset price in ETH\n     */\n    function getAssetPrice(address _asset) external view returns (uint256);\n}\n"
    },
    "contracts/aave/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n@title IReserveInterestRateStrategyInterface interface\n@notice Interface for the calculation of the interest rates.\n*/\n\ninterface IReserveInterestRateStrategy {\n\n    /**\n    * @dev returns the base variable borrow rate, in rays\n    */\n\n    function getBaseVariableBorrowRate() external view returns (uint256);\n    /**\n    * @dev calculates the liquidity, stable, and variable rates depending on the current utilization rate\n    *      and the base parameters\n    *\n    */\n    function calculateInterestRates(\n        address _reserve,\n        uint256 _utilizationRate,\n        uint256 _totalBorrowsStable,\n        uint256 _totalBorrowsVariable,\n        uint256 _averageStableBorrowRate)\n    external\n    view\n    returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\n}\n"
    },
    "contracts/aave/lendingpool/DefaultReserveInterestRateStrategy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../interfaces/IReserveInterestRateStrategy.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"./LendingPoolCore.sol\";\nimport \"../interfaces/ILendingRateOracle.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n* @title DefaultReserveInterestRateStrategy contract\n* @notice implements the calculation of the interest rates depending on the reserve parameters.\n* @dev if there is need to update the calculation of the interest rates for a specific reserve,\n* a new version of this contract will be deployed.\n* @author Aave\n**/\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n    using WadRayMath for uint256;\n    using SafeMath for uint256;\n\n\n\n   /**\n    * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates\n    * expressed in ray\n    **/\n    uint256 public constant OPTIMAL_UTILIZATION_RATE = 0.8 * 1e27;\n\n   /**\n    * @dev this constant represents the excess utilization rate above the optimal. It's always equal to\n    * 1-optimal utilization rate. Added as a constant here for gas optimizations\n    * expressed in ray\n    **/\n\n    uint256 public constant EXCESS_UTILIZATION_RATE = 0.2 * 1e27;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n\n    //base variable borrow rate when Utilization rate = 0. Expressed in ray\n    uint256 public baseVariableBorrowRate;\n\n    //slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 public variableRateSlope1;\n\n    //slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 public variableRateSlope2;\n\n    //slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 public stableRateSlope1;\n\n    //slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 public stableRateSlope2;\n    address public reserve;\n\n    constructor(\n        address _reserve,\n        LendingPoolAddressesProvider _provider,\n        uint256 _baseVariableBorrowRate,\n        uint256 _variableRateSlope1,\n        uint256 _variableRateSlope2,\n        uint256 _stableRateSlope1,\n        uint256 _stableRateSlope2\n    ) public {\n        addressesProvider = _provider;\n        baseVariableBorrowRate = _baseVariableBorrowRate;\n        variableRateSlope1 = _variableRateSlope1;\n        variableRateSlope2 = _variableRateSlope2;\n        stableRateSlope1 = _stableRateSlope1;\n        stableRateSlope2 = _stableRateSlope2;\n        reserve = _reserve;\n    }\n\n    /**\n    @dev accessors\n     */\n\n    function getBaseVariableBorrowRate() external view returns (uint256) {\n        return baseVariableBorrowRate;\n    }\n\n    function getVariableRateSlope1() external view returns (uint256) {\n        return variableRateSlope1;\n    }\n\n    function getVariableRateSlope2() external view returns (uint256) {\n        return variableRateSlope2;\n    }\n\n    function getStableRateSlope1() external view returns (uint256) {\n        return stableRateSlope1;\n    }\n\n    function getStableRateSlope2() external view returns (uint256) {\n        return stableRateSlope2;\n    }\n\n    /**\n    * @dev calculates the interest rates depending on the available liquidity and the total borrowed.\n    * @param _reserve the address of the reserve\n    * @param _availableLiquidity the liquidity available in the reserve\n    * @param _totalBorrowsStable the total borrowed from the reserve a stable rate\n    * @param _totalBorrowsVariable the total borrowed from the reserve at a variable rate\n    * @param _averageStableBorrowRate the weighted average of all the stable rate borrows\n    * @return the liquidity rate, stable borrow rate and variable borrow rate calculated from the input parameters\n    **/\n    function calculateInterestRates(\n        address _reserve,\n        uint256 _availableLiquidity,\n        uint256 _totalBorrowsStable,\n        uint256 _totalBorrowsVariable,\n        uint256 _averageStableBorrowRate\n    )\n        external\n        view\n        returns (\n            uint256 currentLiquidityRate,\n            uint256 currentStableBorrowRate,\n            uint256 currentVariableBorrowRate\n        )\n    {\n        uint256 totalBorrows = _totalBorrowsStable.add(_totalBorrowsVariable);\n\n        uint256 utilizationRate = (totalBorrows == 0 && _availableLiquidity == 0)\n            ? 0\n            : totalBorrows.rayDiv(_availableLiquidity.add(totalBorrows));\n\n        currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle())\n            .getMarketBorrowRate(_reserve);\n\n        if (utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n            uint256 excessUtilizationRateRatio = utilizationRate\n                .sub(OPTIMAL_UTILIZATION_RATE)\n                .rayDiv(EXCESS_UTILIZATION_RATE);\n\n            currentStableBorrowRate = currentStableBorrowRate.add(stableRateSlope1).add(\n                stableRateSlope2.rayMul(excessUtilizationRateRatio)\n            );\n\n            currentVariableBorrowRate = baseVariableBorrowRate.add(variableRateSlope1).add(\n                variableRateSlope2.rayMul(excessUtilizationRateRatio)\n            );\n        } else {\n            currentStableBorrowRate = currentStableBorrowRate.add(\n                stableRateSlope1.rayMul(\n                    utilizationRate.rayDiv(\n                        OPTIMAL_UTILIZATION_RATE\n                    )\n                )\n            );\n            currentVariableBorrowRate = baseVariableBorrowRate.add(\n                utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE).rayMul(variableRateSlope1)\n            );\n        }\n\n        currentLiquidityRate = getOverallBorrowRateInternal(\n            _totalBorrowsStable,\n            _totalBorrowsVariable,\n            currentVariableBorrowRate,\n            _averageStableBorrowRate\n        )\n            .rayMul(utilizationRate);\n\n    }\n\n    /**\n    * @dev calculates the overall borrow rate as the weighted average between the total variable borrows and total stable borrows.\n    * @param _totalBorrowsStable the total borrowed from the reserve a stable rate\n    * @param _totalBorrowsVariable the total borrowed from the reserve at a variable rate\n    * @param _currentVariableBorrowRate the current variable borrow rate\n    * @param _currentAverageStableBorrowRate the weighted average of all the stable rate borrows\n    * @return the weighted averaged borrow rate\n    **/\n    function getOverallBorrowRateInternal(\n        uint256 _totalBorrowsStable,\n        uint256 _totalBorrowsVariable,\n        uint256 _currentVariableBorrowRate,\n        uint256 _currentAverageStableBorrowRate\n    ) internal pure returns (uint256) {\n        uint256 totalBorrows = _totalBorrowsStable.add(_totalBorrowsVariable);\n\n        if (totalBorrows == 0) return 0;\n\n        uint256 weightedVariableRate = _totalBorrowsVariable.wadToRay().rayMul(\n            _currentVariableBorrowRate\n        );\n\n        uint256 weightedStableRate = _totalBorrowsStable.wadToRay().rayMul(\n            _currentAverageStableBorrowRate\n        );\n\n        uint256 overallBorrowRate = weightedVariableRate.add(weightedStableRate).rayDiv(\n            totalBorrows.wadToRay()\n        );\n\n        return overallBorrowRate;\n    }\n}\n"
    },
    "contracts/aave/lendingpool/LendingPoolCore.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\n\nimport \"../libraries/CoreLibrary.sol\";\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../interfaces/ILendingRateOracle.sol\";\nimport \"../interfaces/IReserveInterestRateStrategy.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../tokenization/AToken.sol\";\nimport \"../libraries/EthAddressLib.sol\";\n\n/**\n* @title LendingPoolCore contract\n* @author Aave\n* @notice Holds the state of the lending pool and all the funds deposited\n* @dev NOTE: The core does not enforce security checks on the update of the state\n* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n* The check that an action can be performed is a duty of the overlying LendingPool contract.\n**/\n\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n\n    /**\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    **/\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    address public lendingPoolAddress;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /**\n    * @dev only lending pools can use functions affected by this modifier\n    **/\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, \"The caller must be a lending pool contract\");\n        _;\n    }\n\n    /**\n    * @dev only lending pools configurator can use functions affected by this modifier\n    **/\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            \"The caller must be a lending pool configurator contract\"\n        );\n        _;\n    }\n\n    mapping(address => CoreLibrary.ReserveData) internal reserves;\n    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;\n\n    address[] public reservesList;\n\n    uint256 public constant CORE_REVISION = 0x4;\n\n    /**\n    * @dev returns the revision number of the contract\n    **/\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n\n    /**\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    **/\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    /**\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    **/\n\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n\n    /**\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    **/\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n\n    /**\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    **/\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n\n    /**\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    **/\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n\n    /**\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    **/\n\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n\n    /**\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    **/\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n\n    /**\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    **/\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n\n    }\n\n    /**\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    **/\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n        external\n        onlyLendingPool\n        returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n\n    /**\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    **/\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n        public\n        onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n\n    /**\n    * @notice ETH/token transfer functions\n    **/\n\n    /**\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    **/\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), \"Only contracts can send ether to the Lending pool core\");\n\n    }\n\n    /**\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    **/\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n        external\n        onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)(\"\");\n            require(result, \"Transfer of ETH failed\");\n        }\n    }\n\n    /**\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    **/\n\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                \"User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction\"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value >= _amount, \"The amount and the value sent to deposit do not match\");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\"\");\n            require(result, \"Transfer of ETH failed\");\n        }\n    }\n\n    /**\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    **/\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            \"Fee liquidation does not require any transfer of value\"\n        );\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\"\");\n            require(result, \"Transfer of ETH failed\");\n        }\n    }\n\n    /**\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    **/\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n        external\n        payable\n        onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, \"User is sending ETH along with the ERC20 transfer.\");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n\n        } else {\n            require(msg.value >= _amount, \"The amount and the value sent to deposit do not match\");\n\n            if (msg.value > _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)(\"\");\n                require(result, \"Transfer of ETH failed\");\n            }\n        }\n    }\n\n    /**\n    * @notice data access functions\n    **/\n\n    /**\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    **/\n    function getUserBasicReserveData(address _reserve, address _user)\n        external\n        view\n        returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n\n        return (\n            underlyingBalance,\n            user.getCompoundedBorrowBalance(reserve),\n            user.originationFee,\n            user.useAsCollateral\n        );\n    }\n\n    /**\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    **/\n\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n        external\n        view\n        returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (!reserve.isStableBorrowRateEnabled) return false;\n\n        return\n            !user.useAsCollateral ||\n            !reserve.usageAsCollateralEnabled ||\n            _amount > getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n\n    /**\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    **/\n\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n\n    }\n\n    /**\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    **/\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n\n    /**\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    **/\n\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n\n    /**\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    **/\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n\n    /**\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    **/\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n\n    /**\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    **/\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n\n    /**\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    **/\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n\n    /**\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    **/\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n\n    /**\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    **/\n\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n\n    /**\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    **/\n\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n\n    /**\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    **/\n\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n\n    /**\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    **/\n\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n                IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n                .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n\n    /**\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    **/\n\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n\n        return reserve.currentStableBorrowRate;\n    }\n\n    /**\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    **/\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n\n    /**\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    **/\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n\n    /**\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    **/\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n\n    /**\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    **/\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n        external\n        view\n        returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n\n    /**\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    **/\n    function getReserveConfiguration(address _reserve)\n        external\n        view\n        returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n\n    /**\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    **/\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n\n    /**\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    **/\n\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n\n    /**\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    **/\n\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n\n    /**\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    **/\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n\n    /**\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    **/\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n\n    /**\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    **/\n\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n\n    /**\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    **/\n\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n\n    /**\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    **/\n\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        uint256 totalBorrows = reserve.getTotalBorrows();\n\n        if (totalBorrows == 0) {\n            return 0;\n        }\n\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n\n    /**\n    * @return the array of reserves configured on the core\n    **/\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n\n    /**\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    **/\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n        external\n        view\n        returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n\n    /**\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    **/\n    function getUserOriginationFee(address _reserve, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n\n    /**\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    **/\n\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n        public\n        view\n        returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n\n        return\n            user.stableBorrowRate > 0\n            ? CoreLibrary.InterestRateMode.STABLE\n            : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n\n    /**\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    **/\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n        internal\n        view\n        returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n\n        return\n            rateMode == CoreLibrary.InterestRateMode.STABLE\n            ? usersReserveData[_user][_reserve].stableBorrowRate\n            : reserves[_reserve].currentVariableBorrowRate;\n    }\n\n    /**\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    **/\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n\n    /**\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    **/\n\n    function getUserBorrowBalances(address _reserve, address _user)\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n\n    /**\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    **/\n\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n\n    /**\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    **/\n\n    function getUserLastUpdate(address _reserve, address _user)\n        external\n        view\n        returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n\n    /**\n    * @dev updates the lending pool core configuration\n    **/\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n\n    /**\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    **/\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n\n    }\n\n\n\n    /**\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    **/\n    function removeLastAddedReserve(address _reserveToRemove)\n     external onlyLendingPoolConfigurator {\n\n        address lastReserve = reservesList[reservesList.length-1];\n\n        require(lastReserve == _reserveToRemove, \"Reserve being removed is different than the reserve requested\");\n\n        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, \"Cannot remove a reserve with liquidity deposited\");\n\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n\n        reservesList.pop();\n    }\n\n    /**\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    **/\n\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n        external\n        onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n\n    /**\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    **/\n\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n        external\n        onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n\n    /**\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    **/\n\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n\n    /**\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    **/\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /**\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    **/\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n\n    /**\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n\n    /**\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n\n    /**\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        require(\n            reserve.lastLiquidityCumulativeIndex > 0 &&\n                reserve.lastVariableBorrowCumulativeIndex > 0,\n            \"Reserve has not been initialized yet\"\n        );\n        reserve.isActive = true;\n    }\n\n    /**\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n\n    /**\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    **/\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n\n    /**\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    **/\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n\n    /**\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    **/\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n        external\n        onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n\n    /**\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    **/\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n        external\n        onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n\n    /**\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    **/\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n        external\n        onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n\n    /**\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    **/\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n        external\n        onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n\n    /**\n    * @notice internal functions\n    **/\n\n    /**\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    **/\n\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n\n    /**\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    **/\n\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert(\"Invalid borrow rate mode\");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /**\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    **/\n\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n\n    /**\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    **/\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /**\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    **/\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n\n        } else {\n            revert(\"Invalid rate mode received\");\n        }\n    }\n\n    /**\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    **/\n\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert(\"Invalid interest rate mode received\");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n        return newMode;\n    }\n\n    /**\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    **/\n\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n\n    }\n\n    /**\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    **/\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n\n    }\n\n    /**\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    **/\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n\n        if(_feeLiquidated > 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    **/\n\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        reserve.updateCumulativeIndexes();\n\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n\n    }\n\n    /**\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    **/\n\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    **/\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert(\"Invalid new borrow rate mode\");\n        }\n    }\n\n    /**\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    **/\n\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n                .interestRateStrategyAddress\n        )\n            .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n\n    /**\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    **/\n\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n\n    /**\n    * @dev updates the internal configuration of the core\n    **/\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n\n    /**\n    * @dev adds a reserve to the array of the reserves address\n    **/\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i < reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n\n}\n"
    },
    "contracts/aave/libraries/CoreLibrary.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./WadRayMath.sol\";\n\n/**\n* @title CoreLibrary library\n* @author Aave\n* @notice Defines the data structures of the reserves and the user data\n**/\nlibrary CoreLibrary {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    struct UserReserveData {\n        //principal amount borrowed by the user.\n        uint256 principalBorrowBalance;\n        //cumulated variable borrow index for the user. Expressed in ray\n        uint256 lastVariableBorrowCumulativeIndex;\n        //origination fee cumulated by the user\n        uint256 originationFee;\n        // stable borrow rate at which the user has borrowed. Expressed in ray\n        uint256 stableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //defines if a specific deposit should or not be used as a collateral in borrows\n        bool useAsCollateral;\n    }\n\n    struct ReserveData {\n        /**\n        * @dev refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n        **/\n        //the liquidity index. Expressed in ray\n        uint256 lastLiquidityCumulativeIndex;\n        //the current supply rate. Expressed in ray\n        uint256 currentLiquidityRate;\n        //the total borrows of the reserve at a stable rate. Expressed in the currency decimals\n        uint256 totalBorrowsStable;\n        //the total borrows of the reserve at a variable rate. Expressed in the currency decimals\n        uint256 totalBorrowsVariable;\n        //the current variable borrow rate. Expressed in ray\n        uint256 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint256 currentStableBorrowRate;\n        //the current average stable borrow rate (weighted average of all the different stable rate loans). Expressed in ray\n        uint256 currentAverageStableBorrowRate;\n        //variable borrow index. Expressed in ray\n        uint256 lastVariableBorrowCumulativeIndex;\n        //the ltv of the reserve. Expressed in percentage (0-100)\n        uint256 baseLTVasCollateral;\n        //the liquidation threshold of the reserve. Expressed in percentage (0-100)\n        uint256 liquidationThreshold;\n        //the liquidation bonus of the reserve. Expressed in percentage\n        uint256 liquidationBonus;\n        //the decimals of the reserve asset\n        uint256 decimals;\n        /**\n        * @dev address of the aToken representing the asset\n        **/\n        address aTokenAddress;\n        /**\n        * @dev address of the interest rate strategy contract\n        **/\n        address interestRateStrategyAddress;\n        uint40 lastUpdateTimestamp;\n        // borrowingEnabled = true means users can borrow from this reserve\n        bool borrowingEnabled;\n        // usageAsCollateralEnabled = true means users can use this reserve as collateral\n        bool usageAsCollateralEnabled;\n        // isStableBorrowRateEnabled = true means users can borrow at a stable rate\n        bool isStableBorrowRateEnabled;\n        // isActive = true means the reserve has been activated and properly configured\n        bool isActive;\n        // isFreezed = true means the reserve only allows repays and redeems, but not deposits, new borrowings or rate swap\n        bool isFreezed;\n    }\n\n    /**\n    * @dev returns the ongoing normalized income for the reserve.\n    * a value of 1e27 means there is no income. As time passes, the income is accrued.\n    * A value of 2*1e27 means that the income of the reserve is double the initial amount.\n    * @param _reserve the reserve object\n    * @return the normalized income. expressed in ray\n    **/\n    function getNormalizedIncome(CoreLibrary.ReserveData storage _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 cumulated = calculateLinearInterest(\n            _reserve\n                .currentLiquidityRate,\n            _reserve\n                .lastUpdateTimestamp\n        )\n            .rayMul(_reserve.lastLiquidityCumulativeIndex);\n\n        return cumulated;\n\n    }\n\n    /**\n    * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\n    * a formal specification.\n    * @param _self the reserve object\n    **/\n    function updateCumulativeIndexes(ReserveData storage _self) internal {\n        uint256 totalBorrows = getTotalBorrows(_self);\n\n        if (totalBorrows > 0) {\n            //only cumulating if there is any income being produced\n            uint256 cumulatedLiquidityInterest = calculateLinearInterest(\n                _self.currentLiquidityRate,\n                _self.lastUpdateTimestamp\n            );\n\n            _self.lastLiquidityCumulativeIndex = cumulatedLiquidityInterest.rayMul(\n                _self.lastLiquidityCumulativeIndex\n            );\n\n            uint256 cumulatedVariableBorrowInterest = calculateCompoundedInterest(\n                _self.currentVariableBorrowRate,\n                _self.lastUpdateTimestamp\n            );\n            _self.lastVariableBorrowCumulativeIndex = cumulatedVariableBorrowInterest.rayMul(\n                _self.lastVariableBorrowCumulativeIndex\n            );\n        }\n    }\n\n    /**\n    * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\n    * the flashloan fee to the reserve, and spread it through the depositors.\n    * @param _self the reserve object\n    * @param _totalLiquidity the total liquidity available in the reserve\n    * @param _amount the amount to accomulate\n    **/\n    function cumulateToLiquidityIndex(\n        ReserveData storage _self,\n        uint256 _totalLiquidity,\n        uint256 _amount\n    ) internal {\n        uint256 amountToLiquidityRatio = _amount.wadToRay().rayDiv(_totalLiquidity.wadToRay());\n\n        uint256 cumulatedLiquidity = amountToLiquidityRatio.add(WadRayMath.ray());\n\n        _self.lastLiquidityCumulativeIndex = cumulatedLiquidity.rayMul(\n            _self.lastLiquidityCumulativeIndex\n        );\n    }\n\n    /**\n    * @dev initializes a reserve\n    * @param _self the reserve object\n    * @param _aTokenAddress the address of the overlying atoken contract\n    * @param _decimals the number of decimals of the underlying asset\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    **/\n    function init(\n        ReserveData storage _self,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external {\n        require(_self.aTokenAddress == address(0), \"Reserve has already been initialized\");\n\n        if (_self.lastLiquidityCumulativeIndex == 0) {\n            //if the reserve has not been initialized yet\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\n        }\n\n        if (_self.lastVariableBorrowCumulativeIndex == 0) {\n            _self.lastVariableBorrowCumulativeIndex = WadRayMath.ray();\n        }\n\n        _self.aTokenAddress = _aTokenAddress;\n        _self.decimals = _decimals;\n\n        _self.interestRateStrategyAddress = _interestRateStrategyAddress;\n        _self.isActive = true;\n        _self.isFreezed = false;\n\n    }\n\n    /**\n    * @dev enables borrowing on a reserve\n    * @param _self the reserve object\n    * @param _stableBorrowRateEnabled true if the stable borrow rate must be enabled by default, false otherwise\n    **/\n    function enableBorrowing(ReserveData storage _self, bool _stableBorrowRateEnabled) external {\n        require(_self.borrowingEnabled == false, \"Reserve is already enabled\");\n\n        _self.borrowingEnabled = true;\n        _self.isStableBorrowRateEnabled = _stableBorrowRateEnabled;\n\n    }\n\n    /**\n    * @dev disables borrowing on a reserve\n    * @param _self the reserve object\n    **/\n    function disableBorrowing(ReserveData storage _self) external {\n        _self.borrowingEnabled = false;\n    }\n\n    /**\n    * @dev enables a reserve to be used as collateral\n    * @param _self the reserve object\n    * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\n    * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n    * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\n    **/\n    function enableAsCollateral(\n        ReserveData storage _self,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external {\n        require(\n            _self.usageAsCollateralEnabled == false,\n            \"Reserve is already enabled as collateral\"\n        );\n\n        _self.usageAsCollateralEnabled = true;\n        _self.baseLTVasCollateral = _baseLTVasCollateral;\n        _self.liquidationThreshold = _liquidationThreshold;\n        _self.liquidationBonus = _liquidationBonus;\n\n        if (_self.lastLiquidityCumulativeIndex == 0)\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\n\n    }\n\n    /**\n    * @dev disables a reserve as collateral\n    * @param _self the reserve object\n    **/\n    function disableAsCollateral(ReserveData storage _self) external {\n        _self.usageAsCollateralEnabled = false;\n    }\n\n\n\n    /**\n    * @dev calculates the compounded borrow balance of a user\n    * @param _self the userReserve object\n    * @param _reserve the reserve object\n    * @return the user compounded borrow balance\n    **/\n    function getCompoundedBorrowBalance(\n        CoreLibrary.UserReserveData storage _self,\n        CoreLibrary.ReserveData storage _reserve\n    ) internal view returns (uint256) {\n        if (_self.principalBorrowBalance == 0) return 0;\n\n        uint256 principalBorrowBalanceRay = _self.principalBorrowBalance.wadToRay();\n        uint256 compoundedBalance = 0;\n        uint256 cumulatedInterest = 0;\n\n        if (_self.stableBorrowRate > 0) {\n            cumulatedInterest = calculateCompoundedInterest(\n                _self.stableBorrowRate,\n                _self.lastUpdateTimestamp\n            );\n        } else {\n            //variable interest\n            cumulatedInterest = calculateCompoundedInterest(\n                _reserve\n                    .currentVariableBorrowRate,\n                _reserve\n                    .lastUpdateTimestamp\n            )\n                .rayMul(_reserve.lastVariableBorrowCumulativeIndex)\n                .rayDiv(_self.lastVariableBorrowCumulativeIndex);\n        }\n\n        compoundedBalance = principalBorrowBalanceRay.rayMul(cumulatedInterest).rayToWad();\n\n        if (compoundedBalance == _self.principalBorrowBalance) {\n            //solium-disable-next-line\n            if (_self.lastUpdateTimestamp != block.timestamp) {\n                //no interest cumulation because of the rounding - we add 1 wei\n                //as symbolic cumulated interest to avoid interest free loans.\n\n                return _self.principalBorrowBalance.add(1 wei);\n            }\n        }\n\n        return compoundedBalance;\n    }\n\n    /**\n    * @dev increases the total borrows at a stable rate on a specific reserve and updates the\n    * average stable rate consequently\n    * @param _reserve the reserve object\n    * @param _amount the amount to add to the total borrows stable\n    * @param _rate the rate at which the amount has been borrowed\n    **/\n    function increaseTotalBorrowsStableAndUpdateAverageRate(\n        ReserveData storage _reserve,\n        uint256 _amount,\n        uint256 _rate\n    ) internal {\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\n        //updating reserve borrows stable\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.add(_amount);\n\n        //update the average stable rate\n        //weighted average of all the borrows\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\n            _reserve.currentAverageStableBorrowRate\n        );\n\n        _reserve.currentAverageStableBorrowRate = weightedLastBorrow\n            .add(weightedPreviousTotalBorrows)\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\n    }\n\n    /**\n    * @dev decreases the total borrows at a stable rate on a specific reserve and updates the\n    * average stable rate consequently\n    * @param _reserve the reserve object\n    * @param _amount the amount to substract to the total borrows stable\n    * @param _rate the rate at which the amount has been repaid\n    **/\n    function decreaseTotalBorrowsStableAndUpdateAverageRate(\n        ReserveData storage _reserve,\n        uint256 _amount,\n        uint256 _rate\n    ) internal {\n        require(_reserve.totalBorrowsStable >= _amount, \"Invalid amount to decrease\");\n\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\n\n        //updating reserve borrows stable\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.sub(_amount);\n\n        if (_reserve.totalBorrowsStable == 0) {\n            _reserve.currentAverageStableBorrowRate = 0; //no income if there are no stable rate borrows\n            return;\n        }\n\n        //update the average stable rate\n        //weighted average of all the borrows\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\n            _reserve.currentAverageStableBorrowRate\n        );\n\n        require(\n            weightedPreviousTotalBorrows >= weightedLastBorrow,\n            \"The amounts to subtract don't match\"\n        );\n\n        _reserve.currentAverageStableBorrowRate = weightedPreviousTotalBorrows\n            .sub(weightedLastBorrow)\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\n    }\n\n    /**\n    * @dev increases the total borrows at a variable rate\n    * @param _reserve the reserve object\n    * @param _amount the amount to add to the total borrows variable\n    **/\n    function increaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.add(_amount);\n    }\n\n    /**\n    * @dev decreases the total borrows at a variable rate\n    * @param _reserve the reserve object\n    * @param _amount the amount to substract to the total borrows variable\n    **/\n    function decreaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\n        require(\n            _reserve.totalBorrowsVariable >= _amount,\n            \"The amount that is being subtracted from the variable total borrows is incorrect\"\n        );\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.sub(_amount);\n    }\n\n    /**\n    * @dev function to calculate the interest using a linear interest rate formula\n    * @param _rate the interest rate, in ray\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\n    * @return the interest rate linearly accumulated during the timeDelta, in ray\n    **/\n\n    function calculateLinearInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\n\n        uint256 timeDelta = timeDifference.wadToRay().rayDiv(SECONDS_PER_YEAR.wadToRay());\n\n        return _rate.rayMul(timeDelta).add(WadRayMath.ray());\n    }\n\n    /**\n    * @dev function to calculate the interest using a compounded interest rate formula\n    * @param _rate the interest rate, in ray\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\n    * @return the interest rate compounded during the timeDelta, in ray\n    **/\n    function calculateCompoundedInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\n\n        uint256 ratePerSecond = _rate.div(SECONDS_PER_YEAR);\n\n        return ratePerSecond.add(WadRayMath.ray()).rayPow(timeDifference);\n    }\n\n    /**\n    * @dev returns the total borrows on the reserve\n    * @param _reserve the reserve object\n    * @return the total borrows (stable + variable)\n    **/\n    function getTotalBorrows(CoreLibrary.ReserveData storage _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        return _reserve.totalBorrowsStable.add(_reserve.totalBorrowsVariable);\n    }\n\n}\n"
    },
    "contracts/aave/tokenization/AToken.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\n\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../lendingpool/LendingPool.sol\";\nimport \"../lendingpool/LendingPoolDataProvider.sol\";\nimport \"../lendingpool/LendingPoolCore.sol\";\nimport \"../libraries/WadRayMath.sol\";\n\n/**\n * @title Aave ERC20 AToken\n *\n * @dev Implementation of the interest bearing token for the DLP protocol.\n * @author Aave\n */\ncontract AToken is ERC20, ERC20Detailed {\n    using WadRayMath for uint256;\n\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\n\n    /**\n    * @dev emitted after the redeem action\n    * @param _from the address performing the redeem\n    * @param _value the amount to be redeemed\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\n    * @param _fromIndex the last index of the user\n    **/\n    event Redeem(\n        address indexed _from,\n        uint256 _value,\n        uint256 _fromBalanceIncrease,\n        uint256 _fromIndex\n    );\n\n    /**\n    * @dev emitted after the mint action\n    * @param _from the address performing the mint\n    * @param _value the amount to be minted\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\n    * @param _fromIndex the last index of the user\n    **/\n    event MintOnDeposit(\n        address indexed _from,\n        uint256 _value,\n        uint256 _fromBalanceIncrease,\n        uint256 _fromIndex\n    );\n\n    /**\n    * @dev emitted during the liquidation action, when the liquidator reclaims the underlying\n    * asset\n    * @param _from the address from which the tokens are being burned\n    * @param _value the amount to be burned\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\n    * @param _fromIndex the last index of the user\n    **/\n    event BurnOnLiquidation(\n        address indexed _from,\n        uint256 _value,\n        uint256 _fromBalanceIncrease,\n        uint256 _fromIndex\n    );\n\n    /**\n    * @dev emitted during the transfer action\n    * @param _from the address from which the tokens are being transferred\n    * @param _to the adress of the destination\n    * @param _value the amount to be minted\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\n    * @param _toBalanceIncrease the cumulated balance since the last update of the destination\n    * @param _fromIndex the last index of the user\n    * @param _toIndex the last index of the liquidator\n    **/\n    event BalanceTransfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        uint256 _fromBalanceIncrease,\n        uint256 _toBalanceIncrease,\n        uint256 _fromIndex,\n        uint256 _toIndex\n    );\n\n    /**\n    * @dev emitted when the accumulation of the interest\n    * by an user is redirected to another user\n    * @param _from the address from which the interest is being redirected\n    * @param _to the adress of the destination\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\n    * @param _fromIndex the last index of the user\n    **/\n    event InterestStreamRedirected(\n        address indexed _from,\n        address indexed _to,\n        uint256 _redirectedBalance,\n        uint256 _fromBalanceIncrease,\n        uint256 _fromIndex\n    );\n\n    /**\n    * @dev emitted when the redirected balance of an user is being updated\n    * @param _targetAddress the address of which the balance is being updated\n    * @param _targetBalanceIncrease the cumulated balance since the last update of the target\n    * @param _targetIndex the last index of the user\n    * @param _redirectedBalanceAdded the redirected balance being added\n    * @param _redirectedBalanceRemoved the redirected balance being removed\n    **/\n    event RedirectedBalanceUpdated(\n        address indexed _targetAddress,\n        uint256 _targetBalanceIncrease,\n        uint256 _targetIndex,\n        uint256 _redirectedBalanceAdded,\n        uint256 _redirectedBalanceRemoved\n    );\n\n    event InterestRedirectionAllowanceChanged(\n        address indexed _from,\n        address indexed _to\n    );\n\n    address public underlyingAssetAddress;\n\n    mapping (address => uint256) private userIndexes;\n    mapping (address => address) private interestRedirectionAddresses;\n    mapping (address => uint256) private redirectedBalances;\n    mapping (address => address) private interestRedirectionAllowances;\n\n    LendingPoolAddressesProvider private addressesProvider;\n    LendingPoolCore private core;\n    LendingPool private pool;\n    LendingPoolDataProvider private dataProvider;\n\n    modifier onlyLendingPool {\n        require(\n            msg.sender == address(pool),\n            \"The caller of this function must be a lending pool\"\n        );\n        _;\n    }\n\n    modifier whenTransferAllowed(address _from, uint256 _amount) {\n        require(isTransferAllowed(_from, _amount), \"Transfer cannot be allowed.\");\n        _;\n    }\n\n    constructor(\n        LendingPoolAddressesProvider _addressesProvider,\n        address _underlyingAsset,\n        uint8 _underlyingAssetDecimals,\n        string memory _name,\n        string memory _symbol\n    ) public ERC20Detailed(_name, _symbol, _underlyingAssetDecimals) {\n\n        addressesProvider = _addressesProvider;\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\n        pool = LendingPool(addressesProvider.getLendingPool());\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\n        underlyingAssetAddress = _underlyingAsset;\n    }\n\n    /**\n     * @notice ERC20 implementation internal function backing transfer() and transferFrom()\n     * @dev validates the transfer before allowing it. NOTE: This is not standard ERC20 behavior\n     **/\n    function _transfer(address _from, address _to, uint256 _amount) internal whenTransferAllowed(_from, _amount) {\n\n        executeTransferInternal(_from, _to, _amount);\n    }\n\n\n    /**\n    * @dev redirects the interest generated to a target address.\n    * when the interest is redirected, the user balance is added to\n    * the recepient redirected balance.\n    * @param _to the address to which the interest will be redirected\n    **/\n    function redirectInterestStream(address _to) external {\n        redirectInterestStreamInternal(msg.sender, _to);\n    }\n\n    /**\n    * @dev redirects the interest generated by _from to a target address.\n    * when the interest is redirected, the user balance is added to\n    * the recepient redirected balance. The caller needs to have allowance on\n    * the interest redirection to be able to execute the function.\n    * @param _from the address of the user whom interest is being redirected\n    * @param _to the address to which the interest will be redirected\n    **/\n    function redirectInterestStreamOf(address _from, address _to) external {\n        require(\n            msg.sender == interestRedirectionAllowances[_from],\n            \"Caller is not allowed to redirect the interest of the user\"\n        );\n        redirectInterestStreamInternal(_from,_to);\n    }\n\n    /**\n    * @dev gives allowance to an address to execute the interest redirection\n    * on behalf of the caller.\n    * @param _to the address to which the interest will be redirected. Pass address(0) to reset\n    * the allowance.\n    **/\n    function allowInterestRedirectionTo(address _to) external {\n        require(_to != msg.sender, \"User cannot give allowance to himself\");\n        interestRedirectionAllowances[msg.sender] = _to;\n        emit InterestRedirectionAllowanceChanged(\n            msg.sender,\n            _to\n        );\n    }\n\n    /**\n    * @dev redeems aToken for the underlying asset\n    * @param _amount the amount being redeemed\n    **/\n    function redeem(uint256 _amount) external {\n\n        require(_amount > 0, \"Amount to redeem needs to be > 0\");\n\n        //cumulates the balance of the user\n        (,\n        uint256 currentBalance,\n        uint256 balanceIncrease,\n        uint256 index) = cumulateBalanceInternal(msg.sender);\n\n        uint256 amountToRedeem = _amount;\n\n        //if amount is equal to uint(-1), the user wants to redeem everything\n        if(_amount == UINT_MAX_VALUE){\n            amountToRedeem = currentBalance;\n        }\n\n        require(amountToRedeem <= currentBalance, \"User cannot redeem more than the available balance\");\n\n        //check that the user is allowed to redeem the amount\n        require(isTransferAllowed(msg.sender, amountToRedeem), \"Transfer cannot be allowed.\");\n\n        //if the user is redirecting his interest towards someone else,\n        //we update the redirected balance of the redirection address by adding the accrued interest,\n        //and removing the amount to redeem\n        updateRedirectedBalanceOfRedirectionAddressInternal(msg.sender, balanceIncrease, amountToRedeem);\n\n        // burns tokens equivalent to the amount requested\n        _burn(msg.sender, amountToRedeem);\n\n        bool userIndexReset = false;\n        //reset the user data if the remaining balance is 0\n        if(currentBalance.sub(amountToRedeem) == 0){\n            userIndexReset = resetDataOnZeroBalanceInternal(msg.sender);\n        }\n\n        // executes redeem of the underlying asset\n        pool.redeemUnderlying(\n            underlyingAssetAddress,\n            msg.sender,\n            amountToRedeem,\n            currentBalance.sub(amountToRedeem)\n        );\n\n        emit Redeem(msg.sender, amountToRedeem, balanceIncrease, userIndexReset ? 0 : index);\n    }\n\n    /**\n     * @dev mints token in the event of users depositing the underlying asset into the lending pool\n     * only lending pools can call this function\n     * @param _account the address receiving the minted tokens\n     * @param _amount the amount of tokens to mint\n     */\n    function mintOnDeposit(address _account, uint256 _amount) external onlyLendingPool {\n\n        //cumulates the balance of the user\n        (,\n        ,\n        uint256 balanceIncrease,\n        uint256 index) = cumulateBalanceInternal(_account);\n\n         //if the user is redirecting his interest towards someone else,\n        //we update the redirected balance of the redirection address by adding the accrued interest\n        //and the amount deposited\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);\n\n        //mint an equivalent amount of tokens to cover the new deposit\n        _mint(_account, _amount);\n\n        emit MintOnDeposit(_account, _amount, balanceIncrease, index);\n    }\n\n    /**\n     * @dev burns token in the event of a borrow being liquidated, in case the liquidators reclaims the underlying asset\n     * Transfer of the liquidated asset is executed by the lending pool contract.\n     * only lending pools can call this function\n     * @param _account the address from which burn the aTokens\n     * @param _value the amount to burn\n     **/\n    function burnOnLiquidation(address _account, uint256 _value) external onlyLendingPool {\n\n        //cumulates the balance of the user being liquidated\n        (,uint256 accountBalance,uint256 balanceIncrease,uint256 index) = cumulateBalanceInternal(_account);\n\n        //adds the accrued interest and substracts the burned amount to\n        //the redirected balance\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease, _value);\n\n        //burns the requested amount of tokens\n        _burn(_account, _value);\n\n        bool userIndexReset = false;\n        //reset the user data if the remaining balance is 0\n        if(accountBalance.sub(_value) == 0){\n            userIndexReset = resetDataOnZeroBalanceInternal(_account);\n        }\n\n        emit BurnOnLiquidation(_account, _value, balanceIncrease, userIndexReset ? 0 : index);\n    }\n\n    /**\n     * @dev transfers tokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n     *      only lending pools can call this function\n     * @param _from the address from which transfer the aTokens\n     * @param _to the destination address\n     * @param _value the amount to transfer\n     **/\n    function transferOnLiquidation(address _from, address _to, uint256 _value) external onlyLendingPool {\n\n        //being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n        //so no need to emit a specific event here\n        executeTransferInternal(_from, _to, _value);\n    }\n\n    /**\n    * @dev calculates the balance of the user, which is the\n    * principal balance + interest generated by the principal balance + interest generated by the redirected balance\n    * @param _user the user for which the balance is being calculated\n    * @return the total balance of the user\n    **/\n    function balanceOf(address _user) public view returns(uint256) {\n\n        //current principal balance of the user\n        uint256 currentPrincipalBalance = super.balanceOf(_user);\n        //balance redirected by other users to _user for interest rate accrual\n        uint256 redirectedBalance = redirectedBalances[_user];\n\n        if(currentPrincipalBalance == 0 && redirectedBalance == 0){\n            return 0;\n        }\n        //if the _user is not redirecting the interest to anybody, accrues\n        //the interest for himself\n\n        if(interestRedirectionAddresses[_user] == address(0)){\n\n            //accruing for himself means that both the principal balance and\n            //the redirected balance partecipate in the interest\n            return calculateCumulatedBalanceInternal(\n                _user,\n                currentPrincipalBalance.add(redirectedBalance)\n                )\n                .sub(redirectedBalance);\n        }\n        else {\n            //if the user redirected the interest, then only the redirected\n            //balance generates interest. In that case, the interest generated\n            //by the redirected balance is added to the current principal balance.\n            return currentPrincipalBalance.add(\n                calculateCumulatedBalanceInternal(\n                    _user,\n                    redirectedBalance\n                )\n                .sub(redirectedBalance)\n            );\n        }\n    }\n\n    /**\n    * @dev returns the principal balance of the user. The principal balance is the last\n    * updated stored balance, which does not consider the perpetually accruing interest.\n    * @param _user the address of the user\n    * @return the principal balance of the user\n    **/\n    function principalBalanceOf(address _user) external view returns(uint256) {\n        return super.balanceOf(_user);\n    }\n\n\n    /**\n    * @dev calculates the total supply of the specific aToken\n    * since the balance of every single user increases over time, the total supply\n    * does that too.\n    * @return the current total supply\n    **/\n    function totalSupply() public view returns(uint256) {\n\n        uint256 currentSupplyPrincipal = super.totalSupply();\n\n        if(currentSupplyPrincipal == 0){\n            return 0;\n        }\n\n        return currentSupplyPrincipal\n            .wadToRay()\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\n            .rayToWad();\n    }\n\n\n    /**\n     * @dev Used to validate transfers before actually executing them.\n     * @param _user address of the user to check\n     * @param _amount the amount to check\n     * @return true if the _user can transfer _amount, false otherwise\n     **/\n    function isTransferAllowed(address _user, uint256 _amount) public view returns (bool) {\n        return dataProvider.balanceDecreaseAllowed(underlyingAssetAddress, _user, _amount);\n    }\n\n    /**\n    * @dev returns the last index of the user, used to calculate the balance of the user\n    * @param _user address of the user\n    * @return the last user index\n    **/\n    function getUserIndex(address _user) external view returns(uint256) {\n        return userIndexes[_user];\n    }\n\n\n    /**\n    * @dev returns the address to which the interest is redirected\n    * @param _user address of the user\n    * @return 0 if there is no redirection, an address otherwise\n    **/\n    function getInterestRedirectionAddress(address _user) external view returns(address) {\n        return interestRedirectionAddresses[_user];\n    }\n\n    /**\n    * @dev returns the redirected balance of the user. The redirected balance is the balance\n    * redirected by other accounts to the user, that is accrueing interest for him.\n    * @param _user address of the user\n    * @return the total redirected balance\n    **/\n    function getRedirectedBalance(address _user) external view returns(uint256) {\n        return redirectedBalances[_user];\n    }\n\n    /**\n    * @dev accumulates the accrued interest of the user to the principal balance\n    * @param _user the address of the user for which the interest is being accumulated\n    * @return the previous principal balance, the new principal balance, the balance increase\n    * and the new user index\n    **/\n    function cumulateBalanceInternal(address _user)\n        internal\n        returns(uint256, uint256, uint256, uint256) {\n\n        uint256 previousPrincipalBalance = super.balanceOf(_user);\n\n        //calculate the accrued interest since the last accumulation\n        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);\n        //mints an amount of tokens equivalent to the amount accumulated\n        _mint(_user, balanceIncrease);\n        //updates the user index\n        uint256 index = userIndexes[_user] = core.getReserveNormalizedIncome(underlyingAssetAddress);\n        return (\n            previousPrincipalBalance,\n            previousPrincipalBalance.add(balanceIncrease),\n            balanceIncrease,\n            index\n        );\n    }\n\n    /**\n    * @dev updates the redirected balance of the user. If the user is not redirecting his\n    * interest, nothing is executed.\n    * @param _user the address of the user for which the interest is being accumulated\n    * @param _balanceToAdd the amount to add to the redirected balance\n    * @param _balanceToRemove the amount to remove from the redirected balance\n    **/\n    function updateRedirectedBalanceOfRedirectionAddressInternal(\n        address _user,\n        uint256 _balanceToAdd,\n        uint256 _balanceToRemove\n    ) internal {\n\n        address redirectionAddress = interestRedirectionAddresses[_user];\n        //if there isn't any redirection, nothing to be done\n        if(redirectionAddress == address(0)){\n            return;\n        }\n\n        //compound balances of the redirected address\n        (,,uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(redirectionAddress);\n\n        //updating the redirected balance\n        redirectedBalances[redirectionAddress] = redirectedBalances[redirectionAddress]\n            .add(_balanceToAdd)\n            .sub(_balanceToRemove);\n\n        //if the interest of redirectionAddress is also being redirected, we need to update\n        //the redirected balance of the redirection target by adding the balance increase\n        address targetOfRedirectionAddress = interestRedirectionAddresses[redirectionAddress];\n\n        if(targetOfRedirectionAddress != address(0)){\n            redirectedBalances[targetOfRedirectionAddress] = redirectedBalances[targetOfRedirectionAddress].add(balanceIncrease);\n        }\n\n        emit RedirectedBalanceUpdated(\n            redirectionAddress,\n            balanceIncrease,\n            index,\n            _balanceToAdd,\n            _balanceToRemove\n        );\n    }\n\n    /**\n    * @dev calculate the interest accrued by _user on a specific balance\n    * @param _user the address of the user for which the interest is being accumulated\n    * @param _balance the balance on which the interest is calculated\n    * @return the interest rate accrued\n    **/\n    function calculateCumulatedBalanceInternal(\n        address _user,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return _balance\n            .wadToRay()\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\n            .rayDiv(userIndexes[_user])\n            .rayToWad();\n    }\n\n    /**\n    * @dev executes the transfer of aTokens, invoked by both _transfer() and\n    *      transferOnLiquidation()\n    * @param _from the address from which transfer the aTokens\n    * @param _to the destination address\n    * @param _value the amount to transfer\n    **/\n    function executeTransferInternal(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n\n        require(_value > 0, \"Transferred amount needs to be greater than zero\");\n\n        //cumulate the balance of the sender\n        (,\n        uint256 fromBalance,\n        uint256 fromBalanceIncrease,\n        uint256 fromIndex\n        ) = cumulateBalanceInternal(_from);\n\n        //cumulate the balance of the receiver\n        (,\n        ,\n        uint256 toBalanceIncrease,\n        uint256 toIndex\n        ) = cumulateBalanceInternal(_to);\n\n        //if the sender is redirecting his interest towards someone else,\n        //adds to the redirected balance the accrued interest and removes the amount\n        //being transferred\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from, fromBalanceIncrease, _value);\n\n        //if the receiver is redirecting his interest towards someone else,\n        //adds to the redirected balance the accrued interest and the amount\n        //being transferred\n        updateRedirectedBalanceOfRedirectionAddressInternal(_to, toBalanceIncrease.add(_value), 0);\n\n        //performs the transfer\n        super._transfer(_from, _to, _value);\n\n        bool fromIndexReset = false;\n        //reset the user data if the remaining balance is 0\n        if(fromBalance.sub(_value) == 0){\n            fromIndexReset = resetDataOnZeroBalanceInternal(_from);\n        }\n\n        emit BalanceTransfer(\n            _from,\n            _to,\n            _value,\n            fromBalanceIncrease,\n            toBalanceIncrease,\n            fromIndexReset ? 0 : fromIndex,\n            toIndex\n        );\n    }\n\n    /**\n    * @dev executes the redirection of the interest from one address to another.\n    * immediately after redirection, the destination address will start to accrue interest.\n    * @param _from the address from which transfer the aTokens\n    * @param _to the destination address\n    **/\n    function redirectInterestStreamInternal(\n        address _from,\n        address _to\n    ) internal {\n\n        address currentRedirectionAddress = interestRedirectionAddresses[_from];\n\n        require(_to != currentRedirectionAddress, \"Interest is already redirected to the user\");\n\n        //accumulates the accrued interest to the principal\n        (uint256 previousPrincipalBalance,\n        uint256 fromBalance,\n        uint256 balanceIncrease,\n        uint256 fromIndex) = cumulateBalanceInternal(_from);\n\n        require(fromBalance > 0, \"Interest stream can only be redirected if there is a valid balance\");\n\n        //if the user is already redirecting the interest to someone, before changing\n        //the redirection address we substract the redirected balance of the previous\n        //recipient\n        if(currentRedirectionAddress != address(0)){\n            updateRedirectedBalanceOfRedirectionAddressInternal(_from,0, previousPrincipalBalance);\n        }\n\n        //if the user is redirecting the interest back to himself,\n        //we simply set to 0 the interest redirection address\n        if(_to == _from) {\n            interestRedirectionAddresses[_from] = address(0);\n            emit InterestStreamRedirected(\n                _from,\n                address(0),\n                fromBalance,\n                balanceIncrease,\n                fromIndex\n            );\n            return;\n        }\n\n        //first set the redirection address to the new recipient\n        interestRedirectionAddresses[_from] = _to;\n\n        //adds the user balance to the redirected balance of the destination\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from,fromBalance,0);\n\n        emit InterestStreamRedirected(\n            _from,\n            _to,\n            fromBalance,\n            balanceIncrease,\n            fromIndex\n        );\n    }\n\n    /**\n    * @dev function to reset the interest stream redirection and the user index, if the\n    * user has no balance left.\n    * @param _user the address of the user\n    * @return true if the user index has also been reset, false otherwise. useful to emit the proper user index value\n    **/\n    function resetDataOnZeroBalanceInternal(address _user) internal returns(bool) {\n\n        //if the user has 0 principal balance, the interest stream redirection gets reset\n        interestRedirectionAddresses[_user] = address(0);\n\n        //emits a InterestStreamRedirected event to notify that the redirection has been reset\n        emit InterestStreamRedirected(_user, address(0),0,0,0);\n\n        //if the redirected balance is also 0, we clear up the user index\n        if(redirectedBalances[_user] == 0){\n            userIndexes[_user] = 0;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/aave/lendingpool/LendingPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\n\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../configuration/LendingPoolParametersProvider.sol\";\nimport \"../tokenization/AToken.sol\";\nimport \"../libraries/CoreLibrary.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IFeeProvider.sol\";\nimport \"../flashloan/interfaces/IFlashLoanReceiver.sol\";\nimport \"./LendingPoolCore.sol\";\nimport \"./LendingPoolDataProvider.sol\";\nimport \"./LendingPoolLiquidationManager.sol\";\nimport \"../libraries/EthAddressLib.sol\";\n\n/**\n* @title LendingPool contract\n* @notice Implements the actions of the LendingPool, and exposes accessory methods to fetch the users and reserve data\n* @author Aave\n **/\n\ncontract LendingPool is ReentrancyGuard, VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using Address for address;\n\n    LendingPoolAddressesProvider public addressesProvider;\n    LendingPoolCore public core;\n    LendingPoolDataProvider public dataProvider;\n    LendingPoolParametersProvider public parametersProvider;\n    IFeeProvider feeProvider;\n\n    /**\n    * @dev emitted on deposit\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @param _amount the amount to be deposited\n    * @param _referral the referral number of the action\n    * @param _timestamp the timestamp of the action\n    **/\n    event Deposit(\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _amount,\n        uint16 indexed _referral,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted during a redeem action.\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @param _amount the amount to be deposited\n    * @param _timestamp the timestamp of the action\n    **/\n    event RedeemUnderlying(\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _amount,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted on borrow\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @param _amount the amount to be deposited\n    * @param _borrowRateMode the rate mode, can be either 1-stable or 2-variable\n    * @param _borrowRate the rate at which the user has borrowed\n    * @param _originationFee the origination fee to be paid by the user\n    * @param _borrowBalanceIncrease the balance increase since the last borrow, 0 if it's the first time borrowing\n    * @param _referral the referral number of the action\n    * @param _timestamp the timestamp of the action\n    **/\n    event Borrow(\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _amount,\n        uint256 _borrowRateMode,\n        uint256 _borrowRate,\n        uint256 _originationFee,\n        uint256 _borrowBalanceIncrease,\n        uint16 indexed _referral,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted on repay\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user for which the repay has been executed\n    * @param _repayer the address of the user that has performed the repay action\n    * @param _amountMinusFees the amount repaid minus fees\n    * @param _fees the fees repaid\n    * @param _borrowBalanceIncrease the balance increase since the last action\n    * @param _timestamp the timestamp of the action\n    **/\n    event Repay(\n        address indexed _reserve,\n        address indexed _user,\n        address indexed _repayer,\n        uint256 _amountMinusFees,\n        uint256 _fees,\n        uint256 _borrowBalanceIncrease,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted when a user performs a rate swap\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user executing the swap\n    * @param _newRateMode the new interest rate mode\n    * @param _newRate the new borrow rate\n    * @param _borrowBalanceIncrease the balance increase since the last action\n    * @param _timestamp the timestamp of the action\n    **/\n    event Swap(\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _newRateMode,\n        uint256 _newRate,\n        uint256 _borrowBalanceIncrease,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted when a user enables a reserve as collateral\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    **/\n    event ReserveUsedAsCollateralEnabled(address indexed _reserve, address indexed _user);\n\n    /**\n    * @dev emitted when a user disables a reserve as collateral\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    **/\n    event ReserveUsedAsCollateralDisabled(address indexed _reserve, address indexed _user);\n\n    /**\n    * @dev emitted when the stable rate of a user gets rebalanced\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user for which the rebalance has been executed\n    * @param _newStableRate the new stable borrow rate after the rebalance\n    * @param _borrowBalanceIncrease the balance increase since the last action\n    * @param _timestamp the timestamp of the action\n    **/\n    event RebalanceStableBorrowRate(\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _newStableRate,\n        uint256 _borrowBalanceIncrease,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted when a flashloan is executed\n    * @param _target the address of the flashLoanReceiver\n    * @param _reserve the address of the reserve\n    * @param _amount the amount requested\n    * @param _totalFee the total fee on the amount\n    * @param _protocolFee the part of the fee for the protocol\n    * @param _timestamp the timestamp of the action\n    **/\n    event FlashLoan(\n        address indexed _target,\n        address indexed _reserve,\n        uint256 _amount,\n        uint256 _totalFee,\n        uint256 _protocolFee,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev these events are not emitted directly by the LendingPool\n    * but they are declared here as the LendingPoolLiquidationManager\n    * is executed using a delegateCall().\n    * This allows to have the events in the generated ABI for LendingPool.\n    **/\n\n    /**\n    * @dev emitted when a borrow fee is liquidated\n    * @param _collateral the address of the collateral being liquidated\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user being liquidated\n    * @param _feeLiquidated the total fee liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\n    * @param _timestamp the timestamp of the action\n    **/\n    event OriginationFeeLiquidated(\n        address indexed _collateral,\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted when a borrower is liquidated\n    * @param _collateral the address of the collateral being liquidated\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user being liquidated\n    * @param _purchaseAmount the total amount liquidated\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\n    * @param _liquidator the address of the liquidator\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n    * @param _timestamp the timestamp of the action\n    **/\n    event LiquidationCall(\n        address indexed _collateral,\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _purchaseAmount,\n        uint256 _liquidatedCollateralAmount,\n        uint256 _accruedBorrowInterest,\n        address _liquidator,\n        bool _receiveAToken,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev functions affected by this modifier can only be invoked by the\n    * aToken.sol contract\n    * @param _reserve the address of the reserve\n    **/\n    modifier onlyOverlyingAToken(address _reserve) {\n        require(\n            msg.sender == core.getReserveATokenAddress(_reserve),\n            \"The caller of this function can only be the aToken contract of this reserve\"\n        );\n        _;\n    }\n\n    /**\n    * @dev functions affected by this modifier can only be invoked if the reserve is active\n    * @param _reserve the address of the reserve\n    **/\n    modifier onlyActiveReserve(address _reserve) {\n        requireReserveActiveInternal(_reserve);\n        _;\n    }\n\n    /**\n    * @dev functions affected by this modifier can only be invoked if the reserve is not freezed.\n    * A freezed reserve only allows redeems, repays, rebalances and liquidations.\n    * @param _reserve the address of the reserve\n    **/\n    modifier onlyUnfreezedReserve(address _reserve) {\n        requireReserveNotFreezedInternal(_reserve);\n        _;\n    }\n\n    /**\n    * @dev functions affected by this modifier can only be invoked if the provided _amount input parameter\n    * is not zero.\n    * @param _amount the amount provided\n    **/\n    modifier onlyAmountGreaterThanZero(uint256 _amount) {\n        requireAmountGreaterThanZeroInternal(_amount);\n        _;\n    }\n\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\n\n    uint256 public constant LENDINGPOOL_REVISION = 0x2;\n\n    function getRevision() internal pure returns (uint256) {\n        return LENDINGPOOL_REVISION;\n    }\n\n    /**\n    * @dev this function is invoked by the proxy contract when the LendingPool contract is added to the\n    * AddressesProvider.\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider registry\n    **/\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\n        parametersProvider = LendingPoolParametersProvider(\n            addressesProvider.getLendingPoolParametersProvider()\n        );\n        feeProvider = IFeeProvider(addressesProvider.getFeeProvider());\n    }\n\n    /**\n    * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\n    * is minted.\n    * @param _reserve the address of the reserve\n    * @param _amount the amount to be deposited\n    * @param _referralCode integrators are assigned a referral code and can potentially receive rewards.\n    **/\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\n        external\n        payable\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyUnfreezedReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        AToken aToken = AToken(core.getReserveATokenAddress(_reserve));\n\n        bool isFirstDeposit = aToken.balanceOf(msg.sender) == 0;\n\n        core.updateStateOnDeposit(_reserve, msg.sender, _amount, isFirstDeposit);\n\n        //minting AToken to user 1:1 with the specific exchange rate\n        aToken.mintOnDeposit(msg.sender, _amount);\n\n        //transfer to the core contract\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, _amount);\n\n        //solium-disable-next-line\n        emit Deposit(_reserve, msg.sender, _amount, _referralCode, block.timestamp);\n\n    }\n\n    /**\n    * @dev Redeems the underlying amount of assets requested by _user.\n    * This function is executed by the overlying aToken contract in response to a redeem action.\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user performing the action\n    * @param _amount the underlying amount to be redeemed\n    **/\n    function redeemUnderlying(\n        address _reserve,\n        address payable _user,\n        uint256 _amount,\n        uint256 _aTokenBalanceAfterRedeem\n    )\n        external\n        nonReentrant\n        onlyOverlyingAToken(_reserve)\n        onlyActiveReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        uint256 currentAvailableLiquidity = core.getReserveAvailableLiquidity(_reserve);\n        require(\n            currentAvailableLiquidity >= _amount,\n            \"There is not enough liquidity available to redeem\"\n        );\n\n        core.updateStateOnRedeem(_reserve, _user, _amount, _aTokenBalanceAfterRedeem == 0);\n\n        core.transferToUser(_reserve, _user, _amount);\n\n        //solium-disable-next-line\n        emit RedeemUnderlying(_reserve, _user, _amount, block.timestamp);\n\n    }\n\n    /**\n    * @dev data structures for local computations in the borrow() method.\n    */\n\n    struct BorrowLocalVars {\n        uint256 principalBorrowBalance;\n        uint256 currentLtv;\n        uint256 currentLiquidationThreshold;\n        uint256 borrowFee;\n        uint256 requestedBorrowAmountETH;\n        uint256 amountOfCollateralNeededETH;\n        uint256 userCollateralBalanceETH;\n        uint256 userBorrowBalanceETH;\n        uint256 userTotalFeesETH;\n        uint256 borrowBalanceIncrease;\n        uint256 currentReserveStableRate;\n        uint256 availableLiquidity;\n        uint256 reserveDecimals;\n        uint256 finalUserBorrowRate;\n        CoreLibrary.InterestRateMode rateMode;\n        bool healthFactorBelowThreshold;\n    }\n\n    /**\n    * @dev Allows users to borrow a specific amount of the reserve currency, provided that the borrower\n    * already deposited enough collateral.\n    * @param _reserve the address of the reserve\n    * @param _amount the amount to be borrowed\n    * @param _interestRateMode the interest rate mode at which the user wants to borrow. Can be 0 (STABLE) or 1 (VARIABLE)\n    **/\n    function borrow(\n        address _reserve,\n        uint256 _amount,\n        uint256 _interestRateMode,\n        uint16 _referralCode\n    )\n        external\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyUnfreezedReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\n        BorrowLocalVars memory vars;\n\n        //check that the reserve is enabled for borrowing\n        require(core.isReserveBorrowingEnabled(_reserve), \"Reserve is not enabled for borrowing\");\n        //validate interest rate mode\n        require(\n            uint256(CoreLibrary.InterestRateMode.VARIABLE) == _interestRateMode ||\n                uint256(CoreLibrary.InterestRateMode.STABLE) == _interestRateMode,\n            \"Invalid interest rate mode selected\"\n        );\n\n        //cast the rateMode to coreLibrary.interestRateMode\n        vars.rateMode = CoreLibrary.InterestRateMode(_interestRateMode);\n\n        //check that the amount is available in the reserve\n        vars.availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\n\n        require(\n            vars.availableLiquidity >= _amount,\n            \"There is not enough liquidity available in the reserve\"\n        );\n\n        (\n            ,\n            vars.userCollateralBalanceETH,\n            vars.userBorrowBalanceETH,\n            vars.userTotalFeesETH,\n            vars.currentLtv,\n            vars.currentLiquidationThreshold,\n            ,\n            vars.healthFactorBelowThreshold\n        ) = dataProvider.calculateUserGlobalData(msg.sender);\n\n        require(vars.userCollateralBalanceETH > 0, \"The collateral balance is 0\");\n\n        require(\n            !vars.healthFactorBelowThreshold,\n            \"The borrower can already be liquidated so he cannot borrow more\"\n        );\n\n        //calculating fees\n        vars.borrowFee = feeProvider.calculateLoanOriginationFee(msg.sender, _amount);\n\n        require(vars.borrowFee > 0, \"The amount to borrow is too small\");\n\n        vars.amountOfCollateralNeededETH = dataProvider.calculateCollateralNeededInETH(\n            _reserve,\n            _amount,\n            vars.borrowFee,\n            vars.userBorrowBalanceETH,\n            vars.userTotalFeesETH,\n            vars.currentLtv\n        );\n\n        require(\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n            \"There is not enough collateral to cover a new borrow\"\n        );\n\n        /**\n        * Following conditions need to be met if the user is borrowing at a stable rate:\n        * 1. Reserve must be enabled for stable rate borrowing\n        * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n        *    they are borrowing, to prevent abuses.\n        * 3. Users will be able to borrow only a relatively small, configurable amount of the total\n        *    liquidity\n        **/\n\n        if (vars.rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n            require(\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, _amount),\n                \"User cannot borrow the selected amount with a stable rate\"\n            );\n\n            //calculate the max available loan size in stable rate mode as a percentage of the\n            //available liquidity\n            uint256 maxLoanPercent = parametersProvider.getMaxStableRateBorrowSizePercent();\n            uint256 maxLoanSizeStable = vars.availableLiquidity.mul(maxLoanPercent).div(100);\n\n            require(\n                _amount <= maxLoanSizeStable,\n                \"User is trying to borrow too much liquidity at a stable rate\"\n            );\n        }\n\n        //all conditions passed - borrow is accepted\n        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core.updateStateOnBorrow(\n            _reserve,\n            msg.sender,\n            _amount,\n            vars.borrowFee,\n            vars.rateMode\n        );\n\n        //if we reached this point, we can transfer\n        core.transferToUser(_reserve, msg.sender, _amount);\n\n        emit Borrow(\n            _reserve,\n            msg.sender,\n            _amount,\n            _interestRateMode,\n            vars.finalUserBorrowRate,\n            vars.borrowFee,\n            vars.borrowBalanceIncrease,\n            _referralCode,\n            //solium-disable-next-line\n            block.timestamp\n        );\n    }\n\n    /**\n    * @notice repays a borrow on the specific reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n    * @dev the target user is defined by _onBehalfOf. If there is no repayment on behalf of another account,\n    * _onBehalfOf must be equal to msg.sender.\n    * @param _reserve the address of the reserve on which the user borrowed\n    * @param _amount the amount to repay, or uint256(-1) if the user wants to repay everything\n    * @param _onBehalfOf the address for which msg.sender is repaying.\n    **/\n\n    struct RepayLocalVars {\n        uint256 principalBorrowBalance;\n        uint256 compoundedBorrowBalance;\n        uint256 borrowBalanceIncrease;\n        bool isETH;\n        uint256 paybackAmount;\n        uint256 paybackAmountMinusFees;\n        uint256 currentStableRate;\n        uint256 originationFee;\n    }\n\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf)\n        external\n        payable\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\n        RepayLocalVars memory vars;\n\n        (\n            vars.principalBorrowBalance,\n            vars.compoundedBorrowBalance,\n            vars.borrowBalanceIncrease\n        ) = core.getUserBorrowBalances(_reserve, _onBehalfOf);\n\n        vars.originationFee = core.getUserOriginationFee(_reserve, _onBehalfOf);\n        vars.isETH = EthAddressLib.ethAddress() == _reserve;\n\n        require(vars.compoundedBorrowBalance > 0, \"The user does not have any borrow pending\");\n\n        require(\n            _amount != UINT_MAX_VALUE || msg.sender == _onBehalfOf,\n            \"To repay on behalf of an user an explicit amount to repay is needed.\"\n        );\n\n        //default to max amount\n        vars.paybackAmount = vars.compoundedBorrowBalance.add(vars.originationFee);\n\n        if (_amount != UINT_MAX_VALUE && _amount < vars.paybackAmount) {\n            vars.paybackAmount = _amount;\n        }\n\n        require(\n            !vars.isETH || msg.value >= vars.paybackAmount,\n            \"Invalid msg.value sent for the repayment\"\n        );\n\n        //if the amount is smaller than the origination fee, just transfer the amount to the fee destination address\n        if (vars.paybackAmount <= vars.originationFee) {\n            core.updateStateOnRepay(\n                _reserve,\n                _onBehalfOf,\n                0,\n                vars.paybackAmount,\n                vars.borrowBalanceIncrease,\n                false\n            );\n\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.paybackAmount : 0)(\n                _reserve,\n                _onBehalfOf,\n                vars.paybackAmount,\n                addressesProvider.getTokenDistributor()\n            );\n\n            emit Repay(\n                _reserve,\n                _onBehalfOf,\n                msg.sender,\n                0,\n                vars.paybackAmount,\n                vars.borrowBalanceIncrease,\n                //solium-disable-next-line\n                block.timestamp\n            );\n            return;\n        }\n\n        vars.paybackAmountMinusFees = vars.paybackAmount.sub(vars.originationFee);\n\n        core.updateStateOnRepay(\n            _reserve,\n            _onBehalfOf,\n            vars.paybackAmountMinusFees,\n            vars.originationFee,\n            vars.borrowBalanceIncrease,\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFees\n        );\n\n        //if the user didn't repay the origination fee, transfer the fee to the fee collection address\n        if(vars.originationFee > 0) {\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.originationFee : 0)(\n                _reserve,\n                _onBehalfOf,\n                vars.originationFee,\n                addressesProvider.getTokenDistributor()\n            );\n        }\n\n        //sending the total msg.value if the transfer is ETH.\n        //the transferToReserve() function will take care of sending the\n        //excess ETH back to the caller\n        core.transferToReserve.value(vars.isETH ? msg.value.sub(vars.originationFee) : 0)(\n            _reserve,\n            msg.sender,\n            vars.paybackAmountMinusFees\n        );\n\n        emit Repay(\n            _reserve,\n            _onBehalfOf,\n            msg.sender,\n            vars.paybackAmountMinusFees,\n            vars.originationFee,\n            vars.borrowBalanceIncrease,\n            //solium-disable-next-line\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev borrowers can user this function to swap between stable and variable borrow rate modes.\n    * @param _reserve the address of the reserve on which the user borrowed\n    **/\n    function swapBorrowRateMode(address _reserve)\n        external\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyUnfreezedReserve(_reserve)\n    {\n        (uint256 principalBorrowBalance, uint256 compoundedBorrowBalance, uint256 borrowBalanceIncrease) = core\n            .getUserBorrowBalances(_reserve, msg.sender);\n\n        require(\n            compoundedBorrowBalance > 0,\n            \"User does not have a borrow in progress on this reserve\"\n        );\n\n        CoreLibrary.InterestRateMode currentRateMode = core.getUserCurrentBorrowRateMode(\n            _reserve,\n            msg.sender\n        );\n\n        if (currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            /**\n            * user wants to swap to stable, before swapping we need to ensure that\n            * 1. stable borrow rate is enabled on the reserve\n            * 2. user is not trying to abuse the reserve by depositing\n            * more collateral than he is borrowing, artificially lowering\n            * the interest rate, borrowing at variable, and switching to stable\n            **/\n            require(\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, compoundedBorrowBalance),\n                \"User cannot borrow the selected amount at stable\"\n            );\n        }\n\n        (CoreLibrary.InterestRateMode newRateMode, uint256 newBorrowRate) = core\n            .updateStateOnSwapRate(\n            _reserve,\n            msg.sender,\n            principalBorrowBalance,\n            compoundedBorrowBalance,\n            borrowBalanceIncrease,\n            currentRateMode\n        );\n\n        emit Swap(\n            _reserve,\n            msg.sender,\n            uint256(newRateMode),\n            newBorrowRate,\n            borrowBalanceIncrease,\n            //solium-disable-next-line\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev rebalances the stable interest rate of a user if current liquidity rate > user stable rate.\n    * this is regulated by Aave to ensure that the protocol is not abused, and the user is paying a fair\n    * rate. Anyone can call this function though.\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user to be rebalanced\n    **/\n    function rebalanceStableBorrowRate(address _reserve, address _user)\n        external\n        nonReentrant\n        onlyActiveReserve(_reserve)\n    {\n        (, uint256 compoundedBalance, uint256 borrowBalanceIncrease) = core.getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        //step 1: user must be borrowing on _reserve at a stable rate\n        require(compoundedBalance > 0, \"User does not have any borrow for this reserve\");\n\n        require(\n            core.getUserCurrentBorrowRateMode(_reserve, _user) ==\n                CoreLibrary.InterestRateMode.STABLE,\n            \"The user borrow is variable and cannot be rebalanced\"\n        );\n\n        uint256 userCurrentStableRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\n        uint256 liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\n        uint256 reserveCurrentStableRate = core.getReserveCurrentStableBorrowRate(_reserve);\n        uint256 rebalanceDownRateThreshold = reserveCurrentStableRate.rayMul(\n            WadRayMath.ray().add(parametersProvider.getRebalanceDownRateDelta())\n        );\n\n        //step 2: we have two possible situations to rebalance:\n\n        //1. user stable borrow rate is below the current liquidity rate. The loan needs to be rebalanced,\n        //as this situation can be abused (user putting back the borrowed liquidity in the same reserve to earn on it)\n        //2. user stable rate is above the market avg borrow rate of a certain delta, and utilization rate is low.\n        //In this case, the user is paying an interest that is too high, and needs to be rescaled down.\n        if (\n            userCurrentStableRate < liquidityRate ||\n            userCurrentStableRate > rebalanceDownRateThreshold\n        ) {\n            uint256 newStableRate = core.updateStateOnRebalance(\n                _reserve,\n                _user,\n                borrowBalanceIncrease\n            );\n\n            emit RebalanceStableBorrowRate(\n                _reserve,\n                _user,\n                newStableRate,\n                borrowBalanceIncrease,\n                //solium-disable-next-line\n                block.timestamp\n            );\n\n            return;\n\n        }\n\n        revert(\"Interest rate rebalance conditions were not met\");\n    }\n\n    /**\n    * @dev allows depositors to enable or disable a specific deposit as collateral.\n    * @param _reserve the address of the reserve\n    * @param _useAsCollateral true if the user wants to user the deposit as collateral, false otherwise.\n    **/\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)\n        external\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyUnfreezedReserve(_reserve)\n    {\n        uint256 underlyingBalance = core.getUserUnderlyingAssetBalance(_reserve, msg.sender);\n\n        require(underlyingBalance > 0, \"User does not have any liquidity deposited\");\n\n        require(\n            dataProvider.balanceDecreaseAllowed(_reserve, msg.sender, underlyingBalance),\n            \"User deposit is already being used as collateral\"\n        );\n\n        core.setUserUseReserveAsCollateral(_reserve, msg.sender, _useAsCollateral);\n\n        if (_useAsCollateral) {\n            emit ReserveUsedAsCollateralEnabled(_reserve, msg.sender);\n        } else {\n            emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);\n        }\n    }\n\n    /**\n    * @dev users can invoke this function to liquidate an undercollateralized position.\n    * @param _reserve the address of the collateral to liquidated\n    * @param _reserve the address of the principal reserve\n    * @param _user the address of the borrower\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\n    * he wants to receive the underlying asset directly\n    **/\n    function liquidationCall(\n        address _collateral,\n        address _reserve,\n        address _user,\n        uint256 _purchaseAmount,\n        bool _receiveAToken\n    ) external payable nonReentrant onlyActiveReserve(_reserve) onlyActiveReserve(_collateral) {\n        address liquidationManager = addressesProvider.getLendingPoolLiquidationManager();\n\n        //solium-disable-next-line\n        (bool success, bytes memory result) = liquidationManager.delegatecall(\n            abi.encodeWithSignature(\n                \"liquidationCall(address,address,address,uint256,bool)\",\n                _collateral,\n                _reserve,\n                _user,\n                _purchaseAmount,\n                _receiveAToken\n            )\n        );\n        require(success, \"Liquidation call failed\");\n\n        (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n        if (returnCode != 0) {\n            //error found\n            revert(string(abi.encodePacked(\"Liquidation failed: \", returnMessage)));\n        }\n    }\n\n    /**\n    * @dev allows smartcontracts to access the liquidity of the pool within one transaction,\n    * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan receiver contracts\n    * that must be kept into consideration. For further details please visit https://developers.aave.com\n    * @param _receiver The address of the contract receiving the funds. The receiver should implement the IFlashLoanReceiver interface.\n    * @param _reserve the address of the principal reserve\n    * @param _amount the amount requested for this flashloan\n    **/\n    function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)\n        public\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        //check that the reserve has enough available liquidity\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\n            ? address(core).balance\n            : IERC20(_reserve).balanceOf(address(core));\n\n        require(\n            availableLiquidityBefore >= _amount,\n            \"There is not enough liquidity available to borrow\"\n        );\n\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\n            .getFlashLoanFeesInBips();\n        //calculate amount fee\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\n\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\n        require(\n            amountFee > 0 && protocolFee > 0,\n            \"The requested amount is too small for a flashLoan.\"\n        );\n\n        //get the FlashLoanReceiver instance\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\n\n        address payable userPayable = address(uint160(_receiver));\n\n        //transfer funds to the receiver\n        core.transferToUser(_reserve, userPayable, _amount);\n\n        //execute action of the receiver\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\n\n        //check that the actual balance of the core contract includes the returned amount\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\n            ? address(core).balance\n            : IERC20(_reserve).balanceOf(address(core));\n\n        require(\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\n            \"The actual balance of the protocol is inconsistent\"\n        );\n\n        core.updateStateOnFlashLoan(\n            _reserve,\n            availableLiquidityBefore,\n            amountFee.sub(protocolFee),\n            protocolFee\n        );\n\n        //solium-disable-next-line\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\n    }\n\n    /**\n    * @dev accessory functions to fetch data from the core contract\n    **/\n\n    function getReserveConfigurationData(address _reserve)\n        external\n        view\n        returns (\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            address interestRateStrategyAddress,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive\n        )\n    {\n        return dataProvider.getReserveConfigurationData(_reserve);\n    }\n\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        )\n    {\n        return dataProvider.getReserveData(_reserve);\n    }\n\n    function getUserAccountData(address _user)\n        external\n        view\n        returns (\n            uint256 totalLiquidityETH,\n            uint256 totalCollateralETH,\n            uint256 totalBorrowsETH,\n            uint256 totalFeesETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        )\n    {\n        return dataProvider.getUserAccountData(_user);\n    }\n\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentBorrowBalance,\n            uint256 principalBorrowBalance,\n            uint256 borrowRateMode,\n            uint256 borrowRate,\n            uint256 liquidityRate,\n            uint256 originationFee,\n            uint256 variableBorrowIndex,\n            uint256 lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        )\n    {\n        return dataProvider.getUserReserveData(_reserve, _user);\n    }\n\n    function getReserves() external view returns (address[] memory) {\n        return core.getReserves();\n    }\n\n    /**\n    * @dev internal function to save on code size for the onlyActiveReserve modifier\n    **/\n    function requireReserveActiveInternal(address _reserve) internal view {\n        require(core.getReserveIsActive(_reserve), \"Action requires an active reserve\");\n    }\n\n    /**\n    * @notice internal function to save on code size for the onlyUnfreezedReserve modifier\n    **/\n    function requireReserveNotFreezedInternal(address _reserve) internal view {\n        require(!core.getReserveIsFreezed(_reserve), \"Action requires an unfreezed reserve\");\n    }\n\n    /**\n    * @notice internal function to save on code size for the onlyAmountGreaterThanZero modifier\n    **/\n    function requireAmountGreaterThanZeroInternal(uint256 _amount) internal pure {\n        require(_amount > 0, \"Amount must be greater than 0\");\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"
    },
    "contracts/aave/lendingpool/LendingPoolDataProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\n\nimport \"../libraries/CoreLibrary.sol\";\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IPriceOracleGetter.sol\";\nimport \"../interfaces/IFeeProvider.sol\";\nimport \"../tokenization/AToken.sol\";\n\nimport \"./LendingPoolCore.sol\";\n\n/**\n* @title LendingPoolDataProvider contract\n* @author Aave\n* @notice Implements functions to fetch data from the core, and aggregate them in order to allow computation\n* on the compounded balances and the account balances in ETH\n**/\ncontract LendingPoolDataProvider is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n\n    LendingPoolCore public core;\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /**\n    * @dev specifies the health factor threshold at which the user position is liquidated.\n    * 1e18 by default, if the health factor drops below 1e18, the loan can be liquidated.\n    **/\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n    uint256 public constant DATA_PROVIDER_REVISION = 0x1;\n\n    function getRevision() internal pure returns (uint256) {\n        return DATA_PROVIDER_REVISION;\n    }\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        core = LendingPoolCore(_addressesProvider.getLendingPoolCore());\n    }\n\n    /**\n    * @dev struct to hold calculateUserGlobalData() local computations\n    **/\n    struct UserGlobalDataLocalVars {\n        uint256 reserveUnitPrice;\n        uint256 tokenUnit;\n        uint256 compoundedLiquidityBalance;\n        uint256 compoundedBorrowBalance;\n        uint256 reserveDecimals;\n        uint256 baseLtv;\n        uint256 liquidationThreshold;\n        uint256 originationFee;\n        bool usageAsCollateralEnabled;\n        bool userUsesReserveAsCollateral;\n        address currentReserve;\n    }\n\n    /**\n    * @dev calculates the user data across the reserves.\n    * this includes the total liquidity/collateral/borrow balances in ETH,\n    * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n    * @param _user the address of the user\n    * @return the total liquidity, total collateral, total borrow balances of the user in ETH.\n    * also the average Ltv, liquidation threshold, and the health factor\n    **/\n    function calculateUserGlobalData(address _user)\n        public\n        view\n        returns (\n            uint256 totalLiquidityBalanceETH,\n            uint256 totalCollateralBalanceETH,\n            uint256 totalBorrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 currentLtv,\n            uint256 currentLiquidationThreshold,\n            uint256 healthFactor,\n            bool healthFactorBelowThreshold\n        )\n    {\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\n\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\n        UserGlobalDataLocalVars memory vars;\n\n        address[] memory reserves = core.getReserves();\n\n        for (uint256 i = 0; i < reserves.length; i++) {\n            vars.currentReserve = reserves[i];\n\n            (\n                vars.compoundedLiquidityBalance,\n                vars.compoundedBorrowBalance,\n                vars.originationFee,\n                vars.userUsesReserveAsCollateral\n            ) = core.getUserBasicReserveData(vars.currentReserve, _user);\n\n            if (vars.compoundedLiquidityBalance == 0 && vars.compoundedBorrowBalance == 0) {\n                continue;\n            }\n\n            //fetch reserve data\n            (\n                vars.reserveDecimals,\n                vars.baseLtv,\n                vars.liquidationThreshold,\n                vars.usageAsCollateralEnabled\n            ) = core.getReserveConfiguration(vars.currentReserve);\n\n            vars.tokenUnit = 10 ** vars.reserveDecimals;\n            vars.reserveUnitPrice = oracle.getAssetPrice(vars.currentReserve);\n\n            //liquidity and collateral balance\n            if (vars.compoundedLiquidityBalance > 0) {\n                uint256 liquidityBalanceETH = vars\n                    .reserveUnitPrice\n                    .mul(vars.compoundedLiquidityBalance)\n                    .div(vars.tokenUnit);\n                totalLiquidityBalanceETH = totalLiquidityBalanceETH.add(liquidityBalanceETH);\n\n                if (vars.usageAsCollateralEnabled && vars.userUsesReserveAsCollateral) {\n                    totalCollateralBalanceETH = totalCollateralBalanceETH.add(liquidityBalanceETH);\n                    currentLtv = currentLtv.add(liquidityBalanceETH.mul(vars.baseLtv));\n                    currentLiquidationThreshold = currentLiquidationThreshold.add(\n                        liquidityBalanceETH.mul(vars.liquidationThreshold)\n                    );\n                }\n            }\n\n            if (vars.compoundedBorrowBalance > 0) {\n                totalBorrowBalanceETH = totalBorrowBalanceETH.add(\n                    vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\n                );\n                totalFeesETH = totalFeesETH.add(\n                    vars.originationFee.mul(vars.reserveUnitPrice).div(vars.tokenUnit)\n                );\n            }\n        }\n\n        currentLtv = totalCollateralBalanceETH > 0 ? currentLtv.div(totalCollateralBalanceETH) : 0;\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\n            ? currentLiquidationThreshold.div(totalCollateralBalanceETH)\n            : 0;\n\n        healthFactor = calculateHealthFactorFromBalancesInternal(\n            totalCollateralBalanceETH,\n            totalBorrowBalanceETH,\n            totalFeesETH,\n            currentLiquidationThreshold\n        );\n        healthFactorBelowThreshold = healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n\n    }\n\n    struct balanceDecreaseAllowedLocalVars {\n        uint256 decimals;\n        uint256 collateralBalanceETH;\n        uint256 borrowBalanceETH;\n        uint256 totalFeesETH;\n        uint256 currentLiquidationThreshold;\n        uint256 reserveLiquidationThreshold;\n        uint256 amountToDecreaseETH;\n        uint256 collateralBalancefterDecrease;\n        uint256 liquidationThresholdAfterDecrease;\n        uint256 healthFactorAfterDecrease;\n        bool reserveUsageAsCollateralEnabled;\n    }\n\n    /**\n    * @dev check if a specific balance decrease is allowed (i.e. doesn't bring the user borrow position health factor under 1e18)\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @param _amount the amount to decrease\n    * @return true if the decrease of the balance is allowed\n    **/\n\n    function balanceDecreaseAllowed(address _reserve, address _user, uint256 _amount)\n        external\n        view\n        returns (bool)\n    {\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\n        balanceDecreaseAllowedLocalVars memory vars;\n\n        (\n            vars.decimals,\n            ,\n            vars.reserveLiquidationThreshold,\n            vars.reserveUsageAsCollateralEnabled\n        ) = core.getReserveConfiguration(_reserve);\n\n        if (\n            !vars.reserveUsageAsCollateralEnabled ||\n            !core.isUserUseReserveAsCollateralEnabled(_reserve, _user)\n        ) {\n            return true; //if reserve is not used as collateral, no reasons to block the transfer\n        }\n\n        (\n            ,\n            vars.collateralBalanceETH,\n            vars.borrowBalanceETH,\n            vars.totalFeesETH,\n            ,\n            vars.currentLiquidationThreshold,\n            ,\n\n        ) = calculateUserGlobalData(_user);\n\n        if (vars.borrowBalanceETH == 0) {\n            return true; //no borrows - no reasons to block the transfer\n        }\n\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\n\n        vars.amountToDecreaseETH = oracle.getAssetPrice(_reserve).mul(_amount).div(\n            10 ** vars.decimals\n        );\n\n        vars.collateralBalancefterDecrease = vars.collateralBalanceETH.sub(\n            vars.amountToDecreaseETH\n        );\n\n        //if there is a borrow, there can't be 0 collateral\n        if (vars.collateralBalancefterDecrease == 0) {\n            return false;\n        }\n\n        vars.liquidationThresholdAfterDecrease = vars\n            .collateralBalanceETH\n            .mul(vars.currentLiquidationThreshold)\n            .sub(vars.amountToDecreaseETH.mul(vars.reserveLiquidationThreshold))\n            .div(vars.collateralBalancefterDecrease);\n\n        uint256 healthFactorAfterDecrease = calculateHealthFactorFromBalancesInternal(\n            vars.collateralBalancefterDecrease,\n            vars.borrowBalanceETH,\n            vars.totalFeesETH,\n            vars.liquidationThresholdAfterDecrease\n        );\n\n        return healthFactorAfterDecrease > HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n\n    }\n\n    /**\n   * @notice calculates the amount of collateral needed in ETH to cover a new borrow.\n   * @param _reserve the reserve from which the user wants to borrow\n   * @param _amount the amount the user wants to borrow\n   * @param _fee the fee for the amount that the user needs to cover\n   * @param _userCurrentBorrowBalanceTH the current borrow balance of the user (before the borrow)\n   * @param _userCurrentLtv the average ltv of the user given his current collateral\n   * @return the total amount of collateral in ETH to cover the current borrow balance + the new amount + fee\n   **/\n    function calculateCollateralNeededInETH(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        uint256 _userCurrentBorrowBalanceTH,\n        uint256 _userCurrentFeesETH,\n        uint256 _userCurrentLtv\n    ) external view returns (uint256) {\n        uint256 reserveDecimals = core.getReserveDecimals(_reserve);\n\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\n\n        uint256 requestedBorrowAmountETH = oracle\n            .getAssetPrice(_reserve)\n            .mul(_amount.add(_fee))\n            .div(10 ** reserveDecimals); //price is in ether\n\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n        uint256 collateralNeededInETH = _userCurrentBorrowBalanceTH\n            .add(_userCurrentFeesETH)\n            .add(requestedBorrowAmountETH)\n            .mul(100)\n            .div(_userCurrentLtv); //LTV is calculated in percentage\n\n        return collateralNeededInETH;\n\n    }\n\n    /**\n    * @dev calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\n    * average Loan To Value.\n    * @param collateralBalanceETH the total collateral balance\n    * @param borrowBalanceETH the total borrow balance\n    * @param totalFeesETH the total fees\n    * @param ltv the average loan to value\n    * @return the amount available to borrow in ETH for the user\n    **/\n\n    function calculateAvailableBorrowsETHInternal(\n        uint256 collateralBalanceETH,\n        uint256 borrowBalanceETH,\n        uint256 totalFeesETH,\n        uint256 ltv\n    ) internal view returns (uint256) {\n        uint256 availableBorrowsETH = collateralBalanceETH.mul(ltv).div(100); //ltv is in percentage\n\n        if (availableBorrowsETH < borrowBalanceETH) {\n            return 0;\n        }\n\n        availableBorrowsETH = availableBorrowsETH.sub(borrowBalanceETH.add(totalFeesETH));\n        //calculate fee\n        uint256 borrowFee = IFeeProvider(addressesProvider.getFeeProvider())\n            .calculateLoanOriginationFee(msg.sender, availableBorrowsETH);\n        return availableBorrowsETH.sub(borrowFee);\n    }\n\n    /**\n    * @dev calculates the health factor from the corresponding balances\n    * @param collateralBalanceETH the total collateral balance in ETH\n    * @param borrowBalanceETH the total borrow balance in ETH\n    * @param totalFeesETH the total fees in ETH\n    * @param liquidationThreshold the avg liquidation threshold\n    **/\n    function calculateHealthFactorFromBalancesInternal(\n        uint256 collateralBalanceETH,\n        uint256 borrowBalanceETH,\n        uint256 totalFeesETH,\n        uint256 liquidationThreshold\n    ) internal pure returns (uint256) {\n        if (borrowBalanceETH == 0) return uint256(-1);\n\n        return\n            (collateralBalanceETH.mul(liquidationThreshold).div(100)).wadDiv(\n                borrowBalanceETH.add(totalFeesETH)\n            );\n    }\n\n    /**\n    * @dev returns the health factor liquidation threshold\n    **/\n    function getHealthFactorLiquidationThreshold() public pure returns (uint256) {\n        return HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n    }\n\n    /**\n    * @dev accessory functions to fetch data from the lendingPoolCore\n    **/\n    function getReserveConfigurationData(address _reserve)\n        external\n        view\n        returns (\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            address rateStrategyAddress,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive\n        )\n    {\n        (, ltv, liquidationThreshold, usageAsCollateralEnabled) = core.getReserveConfiguration(\n            _reserve\n        );\n        stableBorrowRateEnabled = core.getReserveIsStableBorrowRateEnabled(_reserve);\n        borrowingEnabled = core.isReserveBorrowingEnabled(_reserve);\n        isActive = core.getReserveIsActive(_reserve);\n        liquidationBonus = core.getReserveLiquidationBonus(_reserve);\n\n        rateStrategyAddress = core.getReserveInterestRateStrategyAddress(_reserve);\n    }\n\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        )\n    {\n        totalLiquidity = core.getReserveTotalLiquidity(_reserve);\n        availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\n        totalBorrowsStable = core.getReserveTotalBorrowsStable(_reserve);\n        totalBorrowsVariable = core.getReserveTotalBorrowsVariable(_reserve);\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\n        variableBorrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\n        stableBorrowRate = core.getReserveCurrentStableBorrowRate(_reserve);\n        averageStableBorrowRate = core.getReserveCurrentAverageStableBorrowRate(_reserve);\n        utilizationRate = core.getReserveUtilizationRate(_reserve);\n        liquidityIndex = core.getReserveLiquidityCumulativeIndex(_reserve);\n        variableBorrowIndex = core.getReserveVariableBorrowsCumulativeIndex(_reserve);\n        aTokenAddress = core.getReserveATokenAddress(_reserve);\n        lastUpdateTimestamp = core.getReserveLastUpdate(_reserve);\n    }\n\n    function getUserAccountData(address _user)\n        external\n        view\n        returns (\n            uint256 totalLiquidityETH,\n            uint256 totalCollateralETH,\n            uint256 totalBorrowsETH,\n            uint256 totalFeesETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        )\n    {\n        (\n            totalLiquidityETH,\n            totalCollateralETH,\n            totalBorrowsETH,\n            totalFeesETH,\n            ltv,\n            currentLiquidationThreshold,\n            healthFactor,\n\n        ) = calculateUserGlobalData(_user);\n\n        availableBorrowsETH = calculateAvailableBorrowsETHInternal(\n            totalCollateralETH,\n            totalBorrowsETH,\n            totalFeesETH,\n            ltv\n        );\n    }\n\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentBorrowBalance,\n            uint256 principalBorrowBalance,\n            uint256 borrowRateMode,\n            uint256 borrowRate,\n            uint256 liquidityRate,\n            uint256 originationFee,\n            uint256 variableBorrowIndex,\n            uint256 lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        )\n    {\n        currentATokenBalance = AToken(core.getReserveATokenAddress(_reserve)).balanceOf(_user);\n        CoreLibrary.InterestRateMode mode = core.getUserCurrentBorrowRateMode(_reserve, _user);\n        (principalBorrowBalance, currentBorrowBalance, ) = core.getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        //default is 0, if mode == CoreLibrary.InterestRateMode.NONE\n        if (mode == CoreLibrary.InterestRateMode.STABLE) {\n            borrowRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\n        } else if (mode == CoreLibrary.InterestRateMode.VARIABLE) {\n            borrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\n        }\n\n        borrowRateMode = uint256(mode);\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\n        originationFee = core.getUserOriginationFee(_reserve, _user);\n        variableBorrowIndex = core.getUserVariableBorrowCumulativeIndex(_reserve, _user);\n        lastUpdateTimestamp = core.getUserLastUpdate(_reserve, _user);\n        usageAsCollateralEnabled = core.isUserUseReserveAsCollateralEnabled(_reserve, _user);\n    }\n}\n"
    },
    "contracts/aave/lendingpool/LendingPoolLiquidationManager.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\n\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../configuration/LendingPoolParametersProvider.sol\";\nimport \"../tokenization/AToken.sol\";\nimport \"../libraries/CoreLibrary.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"./LendingPoolCore.sol\";\nimport \"./LendingPoolDataProvider.sol\";\nimport \"../interfaces/IPriceOracleGetter.sol\";\n\n/**\n* @title LendingPoolLiquidationManager contract\n* @author Aave\n* @notice Implements the liquidation function.\n**/\ncontract LendingPoolLiquidationManager is ReentrancyGuard, VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using Address for address;\n\n    LendingPoolAddressesProvider public addressesProvider;\n    LendingPoolCore core;\n    LendingPoolDataProvider dataProvider;\n    LendingPoolParametersProvider parametersProvider;\n    IFeeProvider feeProvider;\n    address ethereumAddress;\n\n    uint256 constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 50;\n\n    /**\n    * @dev emitted when a borrow fee is liquidated\n    * @param _collateral the address of the collateral being liquidated\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user being liquidated\n    * @param _feeLiquidated the total fee liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\n    * @param _timestamp the timestamp of the action\n    **/\n    event OriginationFeeLiquidated(\n        address indexed _collateral,\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _timestamp\n    );\n\n    /**\n    * @dev emitted when a borrower is liquidated\n    * @param _collateral the address of the collateral being liquidated\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user being liquidated\n    * @param _purchaseAmount the total amount liquidated\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\n    * @param _liquidator the address of the liquidator\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n    * @param _timestamp the timestamp of the action\n    **/\n    event LiquidationCall(\n        address indexed _collateral,\n        address indexed _reserve,\n        address indexed _user,\n        uint256 _purchaseAmount,\n        uint256 _liquidatedCollateralAmount,\n        uint256 _accruedBorrowInterest,\n        address _liquidator,\n        bool _receiveAToken,\n        uint256 _timestamp\n    );\n\n    enum LiquidationErrors {\n        NO_ERROR,\n        NO_COLLATERAL_AVAILABLE,\n        COLLATERAL_CANNOT_BE_LIQUIDATED,\n        CURRRENCY_NOT_BORROWED,\n        HEALTH_FACTOR_ABOVE_THRESHOLD,\n        NOT_ENOUGH_LIQUIDITY\n    }\n\n    struct LiquidationCallLocalVars {\n        uint256 userCollateralBalance;\n        uint256 userCompoundedBorrowBalance;\n        uint256 borrowBalanceIncrease;\n        uint256 maxPrincipalAmountToLiquidate;\n        uint256 actualAmountToLiquidate;\n        uint256 liquidationRatio;\n        uint256 collateralPrice;\n        uint256 principalCurrencyPrice;\n        uint256 maxAmountCollateralToLiquidate;\n        uint256 originationFee;\n        uint256 feeLiquidated;\n        uint256 liquidatedCollateralForFee;\n        CoreLibrary.InterestRateMode borrowRateMode;\n        uint256 userStableRate;\n        bool isCollateralEnabled;\n        bool healthFactorBelowThreshold;\n    }\n\n    /**\n    * @dev as the contract extends the VersionedInitializable contract to match the state\n    * of the LendingPool contract, the getRevision() function is needed.\n    */\n    function getRevision() internal pure returns (uint256) {\n        return 0;\n    }\n\n    /**\n    * @dev users can invoke this function to liquidate an undercollateralized position.\n    * @param _reserve the address of the collateral to liquidated\n    * @param _reserve the address of the principal reserve\n    * @param _user the address of the borrower\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\n    * he wants to receive the underlying asset directly\n    **/\n    function liquidationCall(\n        address _collateral,\n        address _reserve,\n        address _user,\n        uint256 _purchaseAmount,\n        bool _receiveAToken\n    ) external payable returns (uint256, string memory) {\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\n        LiquidationCallLocalVars memory vars;\n\n        (, , , , , , , vars.healthFactorBelowThreshold) = dataProvider.calculateUserGlobalData(\n            _user\n        );\n\n        if (!vars.healthFactorBelowThreshold) {\n            return (\n                uint256(LiquidationErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n                \"Health factor is not below the threshold\"\n            );\n        }\n\n        vars.userCollateralBalance = core.getUserUnderlyingAssetBalance(_collateral, _user);\n\n        //if _user hasn't deposited this specific collateral, nothing can be liquidated\n        if (vars.userCollateralBalance == 0) {\n            return (\n                uint256(LiquidationErrors.NO_COLLATERAL_AVAILABLE),\n                \"Invalid collateral to liquidate\"\n            );\n        }\n\n        vars.isCollateralEnabled =\n            core.isReserveUsageAsCollateralEnabled(_collateral) &&\n            core.isUserUseReserveAsCollateralEnabled(_collateral, _user);\n\n        //if _collateral isn't enabled as collateral by _user, it cannot be liquidated\n        if (!vars.isCollateralEnabled) {\n            return (\n                uint256(LiquidationErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n                \"The collateral chosen cannot be liquidated\"\n            );\n        }\n\n        //if the user hasn't borrowed the specific currency defined by _reserve, it cannot be liquidated\n        (, vars.userCompoundedBorrowBalance, vars.borrowBalanceIncrease) = core\n            .getUserBorrowBalances(_reserve, _user);\n\n        if (vars.userCompoundedBorrowBalance == 0) {\n            return (\n                uint256(LiquidationErrors.CURRRENCY_NOT_BORROWED),\n                \"User did not borrow the specified currency\"\n            );\n        }\n\n        //all clear - calculate the max principal amount that can be liquidated\n        vars.maxPrincipalAmountToLiquidate = vars\n            .userCompoundedBorrowBalance\n            .mul(LIQUIDATION_CLOSE_FACTOR_PERCENT)\n            .div(100);\n\n        vars.actualAmountToLiquidate = _purchaseAmount > vars.maxPrincipalAmountToLiquidate\n            ? vars.maxPrincipalAmountToLiquidate\n            : _purchaseAmount;\n\n        (uint256 maxCollateralToLiquidate, uint256 principalAmountNeeded) = calculateAvailableCollateralToLiquidate(\n            _collateral,\n            _reserve,\n            vars.actualAmountToLiquidate,\n            vars.userCollateralBalance\n        );\n\n        vars.originationFee = core.getUserOriginationFee(_reserve, _user);\n\n        //if there is a fee to liquidate, calculate the maximum amount of fee that can be liquidated\n        if (vars.originationFee > 0) {\n            (\n                vars.liquidatedCollateralForFee,\n                vars.feeLiquidated\n            ) = calculateAvailableCollateralToLiquidate(\n                _collateral,\n                _reserve,\n                vars.originationFee,\n                vars.userCollateralBalance.sub(maxCollateralToLiquidate)\n            );\n        }\n\n        //if principalAmountNeeded < vars.ActualAmountToLiquidate, there isn't enough\n        //of _collateral to cover the actual amount that is being liquidated, hence we liquidate\n        //a smaller amount\n\n        if (principalAmountNeeded < vars.actualAmountToLiquidate) {\n            vars.actualAmountToLiquidate = principalAmountNeeded;\n        }\n\n        //if liquidator reclaims the underlying asset, we make sure there is enough available collateral in the reserve\n        if (!_receiveAToken) {\n            uint256 currentAvailableCollateral = core.getReserveAvailableLiquidity(_collateral);\n            if (currentAvailableCollateral < maxCollateralToLiquidate) {\n                return (\n                    uint256(LiquidationErrors.NOT_ENOUGH_LIQUIDITY),\n                    \"There isn't enough liquidity available to liquidate\"\n                );\n            }\n        }\n\n        core.updateStateOnLiquidation(\n            _reserve,\n            _collateral,\n            _user,\n            vars.actualAmountToLiquidate,\n            maxCollateralToLiquidate,\n            vars.feeLiquidated,\n            vars.liquidatedCollateralForFee,\n            vars.borrowBalanceIncrease,\n            _receiveAToken\n        );\n\n        AToken collateralAtoken = AToken(core.getReserveATokenAddress(_collateral));\n\n        //if liquidator reclaims the aToken, he receives the equivalent atoken amount\n        if (_receiveAToken) {\n            collateralAtoken.transferOnLiquidation(_user, msg.sender, maxCollateralToLiquidate);\n        } else {\n            //otherwise receives the underlying asset\n            //burn the equivalent amount of atoken\n            collateralAtoken.burnOnLiquidation(_user, maxCollateralToLiquidate);\n            core.transferToUser(_collateral, msg.sender, maxCollateralToLiquidate);\n        }\n\n        //transfers the principal currency to the pool\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, vars.actualAmountToLiquidate);\n\n        if (vars.feeLiquidated > 0) {\n            //if there is enough collateral to liquidate the fee, first transfer burn an equivalent amount of\n            //aTokens of the user\n            collateralAtoken.burnOnLiquidation(_user, vars.liquidatedCollateralForFee);\n\n            //then liquidate the fee by transferring it to the fee collection address\n            core.liquidateFee(\n                _collateral,\n                vars.liquidatedCollateralForFee,\n                addressesProvider.getTokenDistributor()\n            );\n\n            emit OriginationFeeLiquidated(\n                _collateral,\n                _reserve,\n                _user,\n                vars.feeLiquidated,\n                vars.liquidatedCollateralForFee,\n                //solium-disable-next-line\n                block.timestamp\n            );\n\n        }\n        emit LiquidationCall(\n            _collateral,\n            _reserve,\n            _user,\n            vars.actualAmountToLiquidate,\n            maxCollateralToLiquidate,\n            vars.borrowBalanceIncrease,\n            msg.sender,\n            _receiveAToken,\n            //solium-disable-next-line\n            block.timestamp\n        );\n\n        return (uint256(LiquidationErrors.NO_ERROR), \"No errors\");\n    }\n\n    struct AvailableCollateralToLiquidateLocalVars {\n        uint256 userCompoundedBorrowBalance;\n        uint256 liquidationBonus;\n        uint256 collateralPrice;\n        uint256 principalCurrencyPrice;\n        uint256 maxAmountCollateralToLiquidate;\n    }\n\n    /**\n    * @dev calculates how much of a specific collateral can be liquidated, given\n    * a certain amount of principal currency. This function needs to be called after\n    * all the checks to validate the liquidation have been performed, otherwise it might fail.\n    * @param _collateral the collateral to be liquidated\n    * @param _principal the principal currency to be liquidated\n    * @param _purchaseAmount the amount of principal being liquidated\n    * @param _userCollateralBalance the collatera balance for the specific _collateral asset of the user being liquidated\n    * @return the maximum amount that is possible to liquidated given all the liquidation constraints (user balance, close factor) and\n    * the purchase amount\n    **/\n    function calculateAvailableCollateralToLiquidate(\n        address _collateral,\n        address _principal,\n        uint256 _purchaseAmount,\n        uint256 _userCollateralBalance\n    ) internal view returns (uint256 collateralAmount, uint256 principalAmountNeeded) {\n        collateralAmount = 0;\n        principalAmountNeeded = 0;\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\n\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\n        AvailableCollateralToLiquidateLocalVars memory vars;\n\n        vars.collateralPrice = oracle.getAssetPrice(_collateral);\n        vars.principalCurrencyPrice = oracle.getAssetPrice(_principal);\n        vars.liquidationBonus = core.getReserveLiquidationBonus(_collateral);\n\n        //this is the maximum possible amount of the selected collateral that can be liquidated, given the\n        //max amount of principal currency that is available for liquidation.\n        vars.maxAmountCollateralToLiquidate = vars\n            .principalCurrencyPrice\n            .mul(_purchaseAmount)\n            .div(vars.collateralPrice)\n            .mul(vars.liquidationBonus)\n            .div(100);\n\n        if (vars.maxAmountCollateralToLiquidate > _userCollateralBalance) {\n            collateralAmount = _userCollateralBalance;\n            principalAmountNeeded = vars\n                .collateralPrice\n                .mul(collateralAmount)\n                .div(vars.principalCurrencyPrice)\n                .mul(100)\n                .div(vars.liquidationBonus);\n        } else {\n            collateralAmount = vars.maxAmountCollateralToLiquidate;\n            principalAmountNeeded = _purchaseAmount;\n        }\n\n        return (collateralAmount, principalAmountNeeded);\n    }\n}\n"
    },
    "contracts/aave/lendingpool/LendingPoolConfigurator.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"./LendingPoolCore.sol\";\nimport \"../tokenization/AToken.sol\";\n\n/**\n* @title LendingPoolConfigurator contract\n* @author Aave\n* @notice Executes configuration methods on the LendingPoolCore contract. Allows to enable/disable reserves,\n* and set different protocol parameters.\n**/\n\ncontract LendingPoolConfigurator is VersionedInitializable {\n    using SafeMath for uint256;\n\n    /**\n    * @dev emitted when a reserve is initialized.\n    * @param _reserve the address of the reserve\n    * @param _aToken the address of the overlying aToken contract\n    * @param _interestRateStrategyAddress the address of the interest rate strategy for the reserve\n    **/\n    event ReserveInitialized(\n        address indexed _reserve,\n        address indexed _aToken,\n        address _interestRateStrategyAddress\n    );\n\n    /**\n    * @dev emitted when a reserve is removed.\n    * @param _reserve the address of the reserve\n    **/\n    event ReserveRemoved(\n        address indexed _reserve\n    );\n\n    /**\n    * @dev emitted when borrowing is enabled on a reserve\n    * @param _reserve the address of the reserve\n    * @param _stableRateEnabled true if stable rate borrowing is enabled, false otherwise\n    **/\n    event BorrowingEnabledOnReserve(address _reserve, bool _stableRateEnabled);\n\n    /**\n    * @dev emitted when borrowing is disabled on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    event BorrowingDisabledOnReserve(address indexed _reserve);\n\n    /**\n    * @dev emitted when a reserve is enabled as collateral.\n    * @param _reserve the address of the reserve\n    * @param _ltv the loan to value of the asset when used as collateral\n    * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n    * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\n    **/\n    event ReserveEnabledAsCollateral(\n        address indexed _reserve,\n        uint256 _ltv,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    );\n\n    /**\n    * @dev emitted when a reserve is disabled as collateral\n    * @param _reserve the address of the reserve\n    **/\n    event ReserveDisabledAsCollateral(address indexed _reserve);\n\n    /**\n    * @dev emitted when stable rate borrowing is enabled on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    event StableRateEnabledOnReserve(address indexed _reserve);\n\n    /**\n    * @dev emitted when stable rate borrowing is disabled on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    event StableRateDisabledOnReserve(address indexed _reserve);\n\n    /**\n    * @dev emitted when a reserve is activated\n    * @param _reserve the address of the reserve\n    **/\n    event ReserveActivated(address indexed _reserve);\n\n    /**\n    * @dev emitted when a reserve is deactivated\n    * @param _reserve the address of the reserve\n    **/\n    event ReserveDeactivated(address indexed _reserve);\n\n    /**\n    * @dev emitted when a reserve is freezed\n    * @param _reserve the address of the reserve\n    **/\n    event ReserveFreezed(address indexed _reserve);\n\n    /**\n    * @dev emitted when a reserve is unfreezed\n    * @param _reserve the address of the reserve\n    **/\n    event ReserveUnfreezed(address indexed _reserve);\n\n    /**\n    * @dev emitted when a reserve loan to value is updated\n    * @param _reserve the address of the reserve\n    * @param _ltv the new value for the loan to value\n    **/\n    event ReserveBaseLtvChanged(address _reserve, uint256 _ltv);\n\n    /**\n    * @dev emitted when a reserve liquidation threshold is updated\n    * @param _reserve the address of the reserve\n    * @param _threshold the new value for the liquidation threshold\n    **/\n    event ReserveLiquidationThresholdChanged(address _reserve, uint256 _threshold);\n\n    /**\n    * @dev emitted when a reserve liquidation bonus is updated\n    * @param _reserve the address of the reserve\n    * @param _bonus the new value for the liquidation bonus\n    **/\n    event ReserveLiquidationBonusChanged(address _reserve, uint256 _bonus);\n\n    /**\n    * @dev emitted when the reserve decimals are updated\n    * @param _reserve the address of the reserve\n    * @param _decimals the new decimals\n    **/\n    event ReserveDecimalsChanged(address _reserve, uint256 _decimals);\n\n\n    /**\n    * @dev emitted when a reserve interest strategy contract is updated\n    * @param _reserve the address of the reserve\n    * @param _strategy the new address of the interest strategy contract\n    **/\n    event ReserveInterestRateStrategyChanged(address _reserve, address _strategy);\n\n    LendingPoolAddressesProvider public poolAddressesProvider;\n    /**\n    * @dev only the lending pool manager can call functions affected by this modifier\n    **/\n    modifier onlyLendingPoolManager {\n        require(\n            poolAddressesProvider.getLendingPoolManager() == msg.sender,\n            \"The caller must be a lending pool manager\"\n        );\n        _;\n    }\n\n    uint256 public constant CONFIGURATOR_REVISION = 0x3;\n\n    function getRevision() internal pure returns (uint256) {\n        return CONFIGURATOR_REVISION;\n    }\n\n    function initialize(LendingPoolAddressesProvider _poolAddressesProvider) public initializer {\n        poolAddressesProvider = _poolAddressesProvider;\n    }\n\n    /**\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve to be initialized\n    * @param _underlyingAssetDecimals the decimals of the reserve underlying asset\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract for this reserve\n    **/\n    function initReserve(\n        address _reserve,\n        uint8 _underlyingAssetDecimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolManager {\n        ERC20Detailed asset = ERC20Detailed(_reserve);\n\n        string memory aTokenName = string(abi.encodePacked(\"Aave Interest bearing \", asset.name()));\n        string memory aTokenSymbol = string(abi.encodePacked(\"a\", asset.symbol()));\n\n        initReserveWithData(\n            _reserve,\n            aTokenName,\n            aTokenSymbol,\n            _underlyingAssetDecimals,\n            _interestRateStrategyAddress\n        );\n\n    }\n\n    /**\n    * @dev initializes a reserve using aTokenData provided externally (useful if the underlying ERC20 contract doesn't expose name or decimals)\n    * @param _reserve the address of the reserve to be initialized\n    * @param _aTokenName the name of the aToken contract\n    * @param _aTokenSymbol the symbol of the aToken contract\n    * @param _underlyingAssetDecimals the decimals of the reserve underlying asset\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract for this reserve\n    **/\n    function initReserveWithData(\n        address _reserve,\n        string memory _aTokenName,\n        string memory _aTokenSymbol,\n        uint8 _underlyingAssetDecimals,\n        address _interestRateStrategyAddress\n    ) public onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n\n        AToken aTokenInstance = new AToken(\n            poolAddressesProvider,\n            _reserve,\n            _underlyingAssetDecimals,\n            _aTokenName,\n            _aTokenSymbol\n        );\n        core.initReserve(\n            _reserve,\n            address(aTokenInstance),\n            _underlyingAssetDecimals,\n            _interestRateStrategyAddress\n        );\n\n        emit ReserveInitialized(\n            _reserve,\n            address(aTokenInstance),\n            _interestRateStrategyAddress\n        );\n    }\n\n    /**\n    * @dev removes the last added reserve in the list of the reserves\n    * @param _reserveToRemove the address of the reserve\n    **/\n    function removeLastAddedReserve( address _reserveToRemove) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.removeLastAddedReserve(_reserveToRemove);\n        emit ReserveRemoved(_reserveToRemove);\n    }\n\n    /**\n    * @dev enables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if stable borrow rate needs to be enabled by default on this reserve\n    **/\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n        external\n        onlyLendingPoolManager\n    {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.enableBorrowingOnReserve(_reserve, _stableBorrowRateEnabled);\n        emit BorrowingEnabledOnReserve(_reserve, _stableBorrowRateEnabled);\n    }\n\n    /**\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.disableBorrowingOnReserve(_reserve);\n\n        emit BorrowingDisabledOnReserve(_reserve);\n    }\n\n    /**\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\n    * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n    * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\n    **/\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.enableReserveAsCollateral(\n            _reserve,\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n        emit ReserveEnabledAsCollateral(\n            _reserve,\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /**\n    * @dev disables a reserve as collateral\n    * @param _reserve the address of the reserve\n    **/\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.disableReserveAsCollateral(_reserve);\n\n        emit ReserveDisabledAsCollateral(_reserve);\n    }\n\n    /**\n    * @dev enable stable rate borrowing on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.enableReserveStableBorrowRate(_reserve);\n\n        emit StableRateEnabledOnReserve(_reserve);\n    }\n\n    /**\n    * @dev disable stable rate borrowing on a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.disableReserveStableBorrowRate(_reserve);\n\n        emit StableRateDisabledOnReserve(_reserve);\n    }\n\n    /**\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function activateReserve(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.activateReserve(_reserve);\n\n        emit ReserveActivated(_reserve);\n    }\n\n    /**\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function deactivateReserve(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        require(core.getReserveTotalLiquidity(_reserve) == 0, \"The liquidity of the reserve needs to be 0\");\n        core.deactivateReserve(_reserve);\n\n        emit ReserveDeactivated(_reserve);\n    }\n\n    /**\n    * @dev freezes a reserve. A freezed reserve doesn't accept any new deposit, borrow or rate swap, but can accept repayments, liquidations, rate rebalances and redeems\n    * @param _reserve the address of the reserve\n    **/\n    function freezeReserve(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.freezeReserve(_reserve);\n\n        emit ReserveFreezed(_reserve);\n    }\n\n    /**\n    * @dev unfreezes a reserve\n    * @param _reserve the address of the reserve\n    **/\n    function unfreezeReserve(address _reserve) external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.unfreezeReserve(_reserve);\n\n        emit ReserveUnfreezed(_reserve);\n    }\n\n    /**\n    * @dev emitted when a reserve loan to value is updated\n    * @param _reserve the address of the reserve\n    * @param _ltv the new value for the loan to value\n    **/\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n        external\n        onlyLendingPoolManager\n    {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.setReserveBaseLTVasCollateral(_reserve, _ltv);\n        emit ReserveBaseLtvChanged(_reserve, _ltv);\n    }\n\n    /**\n    * @dev updates the liquidation threshold of a reserve.\n    * @param _reserve the address of the reserve\n    * @param _threshold the new value for the liquidation threshold\n    **/\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n        external\n        onlyLendingPoolManager\n    {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.setReserveLiquidationThreshold(_reserve, _threshold);\n        emit ReserveLiquidationThresholdChanged(_reserve, _threshold);\n    }\n\n    /**\n    * @dev updates the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new value for the liquidation bonus\n    **/\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n        external\n        onlyLendingPoolManager\n    {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.setReserveLiquidationBonus(_reserve, _bonus);\n        emit ReserveLiquidationBonusChanged(_reserve, _bonus);\n    }\n\n    /**\n    * @dev updates the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the new number of decimals\n    **/\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n        external\n        onlyLendingPoolManager\n    {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.setReserveDecimals(_reserve, _decimals);\n        emit ReserveDecimalsChanged(_reserve, _decimals);\n    }\n\n    /**\n    * @dev sets the interest rate strategy of a reserve\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the new address of the interest strategy contract\n    **/\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n        external\n        onlyLendingPoolManager\n    {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.setReserveInterestRateStrategyAddress(_reserve, _rateStrategyAddress);\n        emit ReserveInterestRateStrategyChanged(_reserve, _rateStrategyAddress);\n    }\n\n    /**\n    * @dev refreshes the lending pool core configuration to update the cached address\n    **/\n    function refreshLendingPoolCoreConfiguration() external onlyLendingPoolManager {\n        LendingPoolCore core = LendingPoolCore(poolAddressesProvider.getLendingPoolCore());\n        core.refreshConfiguration();\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n    /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }\n}\n"
    },
    "contracts/aave/libraries/openzeppelin-upgradeability/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.6.0;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n   * @dev Indicates that the contract has been initialized.\n   */\n    bool private initialized;\n\n    /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n    bool private initializing;\n\n    /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n    modifier initializer() {\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/aave/misc/ChainlinkProxyPriceProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../interfaces/IPriceOracleGetter.sol\";\nimport \"../interfaces/IChainlinkAggregator.sol\";\nimport \"../libraries/EthAddressLib.sol\";\n\n/// @title ChainlinkProxyPriceProvider\n/// @author Aave\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\n///         smart contracts as primary option\n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOracle\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them\n///   and change the fallbackOracle\ncontract ChainlinkProxyPriceProvider is IPriceOracleGetter, Ownable {\n\n    event AssetSourceUpdated(address indexed asset, address indexed source);\n    event FallbackOracleUpdated(address indexed fallbackOracle);\n\n    mapping(address => IChainlinkAggregator) private assetsSources;\n    IPriceOracleGetter private fallbackOracle;\n\n    /// @notice Constructor\n    /// @param _assets The addresses of the assets\n    /// @param _sources The address of the source of each asset\n    /// @param _fallbackOracle The address of the fallback oracle to use if the data of an\n    ///        aggregator is not consistent\n    constructor(address[] memory _assets, address[] memory _sources, address _fallbackOracle) public {\n        internalSetFallbackOracle(_fallbackOracle);\n        internalSetAssetsSources(_assets, _sources);\n    }\n\n    /// @notice External function called by the Aave governance to set or replace sources of assets\n    /// @param _assets The addresses of the assets\n    /// @param _sources The address of the source of each asset\n    function setAssetSources(address[] calldata _assets, address[] calldata _sources) external onlyOwner {\n        internalSetAssetsSources(_assets, _sources);\n    }\n\n    /// @notice Sets the fallbackOracle\n    /// - Callable only by the Aave governance\n    /// @param _fallbackOracle The address of the fallbackOracle\n    function setFallbackOracle(address _fallbackOracle) external onlyOwner {\n        internalSetFallbackOracle(_fallbackOracle);\n    }\n\n    /// @notice Internal function to set the sources for each asset\n    /// @param _assets The addresses of the assets\n    /// @param _sources The address of the source of each asset\n    function internalSetAssetsSources(address[] memory _assets, address[] memory _sources) internal {\n        require(_assets.length == _sources.length, \"INCONSISTENT_PARAMS_LENGTH\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            assetsSources[_assets[i]] = IChainlinkAggregator(_sources[i]);\n            emit AssetSourceUpdated(_assets[i], _sources[i]);\n        }\n    }\n\n    /// @notice Internal function to set the fallbackOracle\n    /// @param _fallbackOracle The address of the fallbackOracle\n    function internalSetFallbackOracle(address _fallbackOracle) internal {\n        fallbackOracle = IPriceOracleGetter(_fallbackOracle);\n        emit FallbackOracleUpdated(_fallbackOracle);\n    }\n\n    /// @notice Gets an asset price by address\n    /// @param _asset The asset address\n    function getAssetPrice(address _asset) public view returns(uint256) {\n        IChainlinkAggregator source = assetsSources[_asset];\n        if (_asset == EthAddressLib.ethAddress()) {\n            return 1 ether;\n        } else {\n            // If there is no registered source for the asset, call the fallbackOracle\n            if (address(source) == address(0)) {\n                return IPriceOracleGetter(fallbackOracle).getAssetPrice(_asset);\n            } else {\n                int256 _price = IChainlinkAggregator(source).latestAnswer();\n                if (_price > 0) {\n                    return uint256(_price);\n                } else {\n                    return IPriceOracleGetter(fallbackOracle).getAssetPrice(_asset);\n                }\n            }\n        }\n    }\n\n    /// @notice Gets a list of prices from a list of assets addresses\n    /// @param _assets The list of assets addresses\n    function getAssetsPrices(address[] calldata _assets) external view returns(uint256[] memory) {\n        uint256[] memory prices = new uint256[](_assets.length);\n        for (uint256 i = 0; i < _assets.length; i++) {\n            prices[i] = getAssetPrice(_assets[i]);\n        }\n        return prices;\n    }\n\n    /// @notice Gets the address of the source for an asset address\n    /// @param _asset The address of the asset\n    /// @return address The address of the source\n    function getSourceOfAsset(address _asset) external view returns(address) {\n        return address(assetsSources[_asset]);\n    }\n\n    /// @notice Gets the address of the fallback oracle\n    /// @return address The addres of the fallback oracle\n    function getFallbackOracle() external view returns(address) {\n        return address(fallbackOracle);\n    }\n}"
    },
    "contracts/aave/misc/IERC20DetailedBytes.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract IERC20DetailedBytes {\n    bytes32  public  name;\n    bytes32  public  symbol;\n    uint256  public  decimals;\n}\n"
    },
    "contracts/aave/misc/WalletBalanceProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../lendingpool/LendingPoolCore.sol\";\nimport \"../libraries/EthAddressLib.sol\";\n\n\n/**\n* @title WalletBalanceProvider contract\n* @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts/BalanceChecker.sol\n* @notice Implements a logic of getting multiple tokens balance for one user address\n* @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to reduce the number of calls\n* towards the blockchain from the Aave backend.\n**/\ncontract WalletBalanceProvider {\n\n    using Address for address;\n\n    LendingPoolAddressesProvider provider;\n\n    constructor(LendingPoolAddressesProvider _provider) public {\n\n        provider = _provider;\n\n    }\n    /**\n    @dev Fallback function, don't accept any ETH\n    **/\n    function() external payable {\n        revert(\"WalletBalanceProvider does not accept payments\");\n    }\n\n    /**\n    @dev Check the token balance of a wallet in a token contract\n\n    Returns the balance of the token for user. Avoids possible errors:\n      - return 0 on non-contract address\n    **/\n    function balanceOf(address _user, address _token) public view returns (uint256) {\n        // check if token is actually a contract\n        if (_token.isContract()) {\n            return IERC20(_token).balanceOf(_user);\n        } else {\n            return 0;\n        }\n    }\n\n\n    /**\n    @dev provides balances of user wallet for all reserves available on the pool\n    */\n    function getUserWalletBalances(address _user) public view returns (address[] memory, uint256[] memory) {\n\n        LendingPoolCore core = LendingPoolCore(provider.getLendingPoolCore());\n\n        address[] memory reserves = core.getReserves();\n\n        uint256[] memory balances = new uint256[](reserves.length);\n\n        for (uint256 j = 0; j < reserves.length; j++) {\n            if(!core.getReserveIsActive(reserves[j])){\n                balances[j] = 0;\n                continue;\n            }\n            if (reserves[j] != EthAddressLib.ethAddress()) {\n                balances[j] = balanceOf(_user, reserves[j]);\n            } else {\n                balances[j] = _user.balance; // ETH balance\n            }\n        }\n\n        return (reserves, balances);\n    }\n}"
    },
    "contracts/aave/mocks/flashloan/MockFlashLoanReceiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../../flashloan/base/FlashLoanReceiverBase.sol\";\nimport \"../tokens/MintableERC20.sol\";\n\ncontract MockFlashLoanReceiver is FlashLoanReceiverBase {\n\n    using SafeMath for uint256;\n    event ExecutedWithFail(address _reserve, uint256 _amount, uint256 _fee);\n    event ExecutedWithSuccess(address _reserve, uint256 _amount, uint256 _fee);\n\n\n    bool failExecution = false;\n\n    constructor(ILendingPoolAddressesProvider _provider) FlashLoanReceiverBase(_provider)  public {\n    }\n\n    function setFailExecutionTransfer(bool _fail) public {\n        failExecution = _fail;\n    }\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes memory _params) public {\n        //mint to this contract the specific amount\n        MintableERC20 token = MintableERC20(_reserve);\n\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve), \"Invalid balance for the contract\");\n\n        if(failExecution) {\n            emit ExecutedWithFail(_reserve, _amount, _fee);\n            return;\n        }\n\n        //execution does not fail - mint tokens and return them to the _destination\n        //note: if the reserve is eth, the mock contract must receive at least _fee ETH before calling executeOperation\n\n        if(_reserve != EthAddressLib.ethAddress()) {\n            token.mint(_fee);\n        }\n        //returning amount + fee to the destination\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n        emit ExecutedWithSuccess(_reserve, _amount, _fee);\n    }\n}"
    },
    "contracts/aave/mocks/tokens/MintableERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract MintableERC20 is ERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(uint256 value) public returns (bool) {\n        _mint(msg.sender, value);\n        return true;\n    }\n}\n"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorBase.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract MockAggregatorBase  {\n    int256 private _latestAnswer;\n\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n\n    constructor (int256 _initialAnswer) public {\n        _latestAnswer = _initialAnswer;\n        emit AnswerUpdated(_initialAnswer, 0, now);\n    }\n\n    function latestAnswer() external view returns (int256) {\n        return _latestAnswer;\n    }\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorBAT.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorBAT is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorDAI.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorDAI is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorKNC.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorKNC is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorLEND.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorLEND is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorLINK.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorLINK is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorMANA.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorMANA is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorMKR.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorMKR is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorREP.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorREP is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorSUSD.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorSUSD is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorTUSD.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorTUSD is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorUSDC.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorUSDC is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorUSDT.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorUSDT is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorWBTC.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorWBTC is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/CLAggregators/MockAggregatorZRX.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./MockAggregatorBase.sol\";\n\ncontract MockAggregatorZRX is MockAggregatorBase {\n    constructor (int256 _initialAnswer) public MockAggregatorBase(_initialAnswer) {}\n}"
    },
    "contracts/aave/mocks/oracle/GenericOracleI.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface GenericOracleI {\n    // ganache\n    event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\n    event EthPriceUpdated(uint256 _price, uint256 timestamp);\n\n    // kovan\n    event ProphecySubmitted(\n        address indexed _sybil,\n        address indexed _asset,\n        uint96 _sybilProphecy,\n        uint96 _oracleProphecy\n    );\n\n    function getAssetPrice(address _asset) external view returns(uint256);\n    function getEthUsdPrice() external view returns(uint256);\n}\n\n"
    },
    "contracts/aave/mocks/oracle/LendingRateOracle.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../interfaces/ILendingRateOracle.sol\";\n\n\ncontract LendingRateOracle is ILendingRateOracle {\n\n    mapping(address => uint256) borrowRates;\n    mapping(address => uint256) liquidityRates;\n\n\n    function getMarketBorrowRate(address _asset) external view returns(uint256) {\n        return borrowRates[_asset];\n    }\n\n    function setMarketBorrowRate(address _asset, uint256 _rate) external {\n        borrowRates[_asset] = _rate;\n    }\n\n    function getMarketLiquidityRate(address _asset) external view returns(uint256) {\n        return liquidityRates[_asset];\n    }\n\n    function setMarketLiquidityRate(address _asset, uint256 _rate) external {\n        liquidityRates[_asset] = _rate;\n    }\n}"
    },
    "contracts/aave/mocks/oracle/PriceOracle.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../interfaces/IPriceOracle.sol\";\n\n\ncontract PriceOracle is IPriceOracle {\n\n    mapping(address => uint256) prices;\n    uint256 ethPriceUsd;\n\n    event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\n    event EthPriceUpdated(uint256 _price, uint256 timestamp);\n\n    function getAssetPrice(address _asset) external view returns(uint256) {\n        return prices[_asset];\n    }\n\n    function setAssetPrice(address _asset, uint256 _price) external {\n        prices[_asset] = _price;\n        emit AssetPriceUpdated(_asset, _price, block.timestamp);\n    }\n\n    function getEthUsdPrice() external view returns(uint256) {\n        return ethPriceUsd;\n    }\n\n    function setEthUsdPrice(uint256 _price) external {\n        ethPriceUsd = _price;\n        emit EthPriceUpdated(_price, block.timestamp);\n    }\n}"
    },
    "contracts/aave/mocks/tokens/MockBAT.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\n\ncontract MockBAT is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"BAT\";\n    string public name = \"Basic Attention Token\";\n}"
    },
    "contracts/aave/mocks/tokens/MockDAI.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\n\ncontract MockDAI is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"DAI\";\n    string public name = \"DAI\";\n}"
    },
    "contracts/aave/mocks/tokens/MockKNC.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockKNC is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"KNC\";\n    string public name = \"Kyber Network\";\n}"
    },
    "contracts/aave/mocks/tokens/MockLEND.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\n\ncontract MockLEND is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"LEND\";\n    string public name = \"LEND\";\n}"
    },
    "contracts/aave/mocks/tokens/MockLINK.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockLINK is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"LINK\";\n    string public name = \"ChainLink\";\n}"
    },
    "contracts/aave/mocks/tokens/MockMANA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockMANA is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"MANA\";\n    string public name = \"Decentraland\";\n}"
    },
    "contracts/aave/mocks/tokens/MockMKR.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockMKR is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"MKR\";\n    string public name = \"Maker\";\n}"
    },
    "contracts/aave/mocks/tokens/MockREP.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockREP is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"REP\";\n    string public name = \"Augur\";\n}"
    },
    "contracts/aave/mocks/tokens/MockSUSD.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockSUSD is MintableERC20 {\n\n    uint256 public decimals = 6;\n    string public symbol = \"SUSD\";\n    string public name = \"Synthetix USD\";\n}"
    },
    "contracts/aave/mocks/tokens/MockTUSD.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockTUSD is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"TUSD\";\n    string public name = \"TrueUSD\";\n}"
    },
    "contracts/aave/mocks/tokens/MockUSDC.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockUSDC is MintableERC20 {\n\n    uint256 public decimals = 6;\n    string public symbol = \"USDC\";\n    string public name = \"USD Coin\";\n}"
    },
    "contracts/aave/mocks/tokens/MockUSDT.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockUSDT is MintableERC20 {\n\n    uint256 public decimals = 6;\n    string public symbol = \"USDT\";\n    string public name = \"USDT Coin\";\n}"
    },
    "contracts/aave/mocks/tokens/MockWBTC.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockWBTC is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"WBTC\";\n    string public name = \"WBTC Coin\";\n}"
    },
    "contracts/aave/mocks/tokens/MockZRX.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./MintableERC20.sol\";\n\n\ncontract MockZRX is MintableERC20 {\n\n    uint256 public decimals = 18;\n    string public symbol = \"ZRX\";\n    string public name = \"0x Coin\";\n}"
    },
    "contracts/aave/mocks/upgradeability/MockLendingPoolCore.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"../../libraries/openzeppelin-upgradeability/VersionedInitializable.sol\";\n\nimport \"../../libraries/CoreLibrary.sol\";\nimport \"../../configuration/LendingPoolAddressesProvider.sol\";\nimport \"../../interfaces/ILendingRateOracle.sol\";\nimport \"../../interfaces/IReserveInterestRateStrategy.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\nimport \"../../lendingpool/LendingPoolCore.sol\";\n\n/*************************************************************************************\n* @title MockLendingPoolCore contract\n* @author Aave\n* @notice This is a mock contract to test upgradeability of the AddressProvider\n *************************************************************************************/\n\ncontract MockLendingPoolCore is LendingPoolCore {\n\n    event ReserveUpdatedFromMock(uint256 indexed revision);\n\n    uint256 constant private CORE_REVISION = 0x5;\n\n    function getRevision() internal pure returns(uint256) {\n        return CORE_REVISION;\n    }\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    function updateReserveInterestRatesAndTimestampInternal(address _reserve, uint256 _liquidityAdded, uint256 _liquidityTaken)\n        internal\n    {\n        super.updateReserveInterestRatesAndTimestampInternal(_reserve, _liquidityAdded, _liquidityTaken);\n\n        emit ReserveUpdatedFromMock(getRevision());\n\n    }\n}\n"
    },
    "contracts/AaveExternalPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IExternalPool.sol\";\n\n/************\n@title IExternalPool interface\n@notice Interface for connection to external lending pools;\n*/\n\nimport \"./aave/tokenization/AToken.sol\";\nimport \"./aave/lendingpool/LendingPool.sol\";\nimport \"./aave/libraries/EthAddressLib.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\ncontract AaveExternalPool is IExternalPool {\n\n  address public reserve;\n  LendingPool public lendingPool;\n\n  constructor(address _reserve, LendingPool _lendingPool) public {\n    reserve = _reserve;\n    lendingPool = _lendingPool;\n  }\n\n  function deposit(uint256 amount) external payable {\n    if (reserve == EthAddressLib.ethAddress()) {\n      lendingPool.deposit.value(amount)(reserve, amount, 0);\n    } else {\n      lendingPool.deposit(reserve, amount, 0);\n    }\n  }\n\n  function withdraw(uint256 amount, address payable beneficiary) external {\n    address aTokenAddress;\n    ( , , , , , , , , , , ,aTokenAddress, ) = lendingPool.getReserveData(reserve);\n    AToken aToken = AToken(aTokenAddress);\n    aToken.redeem(amount);\n    if (reserve == EthAddressLib.ethAddress()) {\n      beneficiary.transfer(amount);\n    } else {\n      ERC20 depositedToken = ERC20(aToken.underlyingAssetAddress());\n      depositedToken.transfer(beneficiary, amount);\n    }\n  }\n\n  function balanceOf(address account) external view returns(uint256) {\n    address aTokenAddress;\n    ( , , , , , , , , , , ,aTokenAddress, ) = lendingPool.getReserveData(reserve);\n    AToken aToken = AToken(aTokenAddress);\n    return aToken.balanceOf(account);\n  }\n}\n"
    },
    "contracts/IExternalPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/************\n@title IExternalPool interface\n@notice Interface for connection to external lending pools;\n*/\n\ninterface IExternalPool {\n\n  function deposit(uint256 amount) external payable;\n\n  function withdraw(uint256 amount, address payable beneficiary) external;\n\n  function balanceOf(address account) external view returns(uint256);\n}\n"
    },
    "contracts/Calendar.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/******************\n@title Calendar\n@dev Simple library for months calculation\n */\n\nlibrary Calendar {\n\n  uint256 internal constant YEAR_START = 1577836800;\n\n  function getCurrentMonth() internal view returns (uint256) {\n    return (now - YEAR_START) / 30 days;\n  }\n\n}\n"
    },
    "contracts/FutureToken.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"./aave/libraries/WadRayMath.sol\";\nimport \"./Calendar.sol\";\nimport \"./IExternalPool.sol\";\nimport \"erc-1155/contracts/IERC1155.sol\";\n\n\n/**\n * @title Future Token\n *\n */\ncontract FutureToken is IERC1155 {\n  using WadRayMath for uint256;\n  using SafeMath for uint256;\n\n  uint256 internal constant MAX_RATE = 10000;\n  uint256 internal constant INTERESTS_SLOT = 7777777;\n  address public constant ETHER = address(0xE);\n\n  /**\n  * @dev emitted after the redeem action\n  * @param _from the address performing the redeem\n  * @param _value the amount to be redeemed\n  * @param _value interests received\n  **/\n  event Deposit(address indexed _from, uint256 _value, uint256 _interests);\n\n  modifier onlyInterestRatesOracle() {\n    require(msg.sender == interestRatesOracle, \"The caller is not the interest rates oracle\");\n    _;\n  }\n\n  mapping (uint256 => mapping(address => uint256)) internal balances;\n\n  IExternalPool public externalPool;\n\n  //An oracle authorized to set interest rates\n  address public interestRatesOracle;\n\n  //A original asset that is going to be deposited and redeemed\n  address public originalAsset;\n\n  //Current interest rate for new deposits and time-travelling\n  uint256 public interestRate;\n\n  constructor(address _interestRatesOracle, IExternalPool _externalPool, address _originalAsset) public {\n    externalPool = _externalPool;\n    interestRatesOracle = _interestRatesOracle;\n    originalAsset = _originalAsset;\n  }\n\n  function setInterestRates(uint _newRate) external onlyInterestRatesOracle {\n    interestRate = _newRate;\n  }\n\n  /**\n   * @notice ERC20 implementation internal function backing transfer() and transferFrom()\n   * @dev validates the transfer before allowing it. NOTE: This is not standard ERC20 behavior\n   **/\n  function deposit(uint256 _amount, uint256 periodDiff) external payable {\n    uint256 interests = getWarpPrice(_amount, periodDiff);\n    uint256 currentPeriod = this.getCurrentPeriod();\n\n    //Deposit to lending pool\n    uint256 lendingPoolDeposit = _amount.sub(interests);\n    if (originalAsset == ETHER) {\n      require(msg.value >= _amount, \"Not enough ether attached to the transaction\");\n      externalPool.deposit.value(lendingPoolDeposit)(lendingPoolDeposit);\n    } else {\n      externalPool.deposit.value(lendingPoolDeposit)(lendingPoolDeposit);\n    }\n\n    //Update internal ledger\n    _mint(msg.sender, currentPeriod.add(periodDiff), _amount);\n    _mint(msg.sender, INTERESTS_SLOT, interests);\n\n    //Return instant interests\n    msg.sender.transfer(interests);\n\n    emit Deposit(msg.sender, _amount, interests);\n  }\n\n\n\n  function withdraw(uint256 _amount) external {\n    uint256 period = this.getCurrentPeriod();\n    require(this.balanceOf(msg.sender, period) >= _amount, \"No enough funds available\");\n\n    //Return funds from Aave\n    uint256 lendingPoolBalance = externalPool.balanceOf(address(this));\n    uint256 toRedeem = _amount > lendingPoolBalance ? lendingPoolBalance : _amount;\n    externalPool.withdraw(toRedeem, msg.sender);\n\n    _burn(msg.sender, period, toRedeem);\n  }\n\n  function warp(uint256 _amount, uint256 _periodFrom, uint256 _periodTo) external payable {\n    require(this.balanceOf(msg.sender, _periodFrom) >= _amount, \"No enough funds available\");\n    require(_periodTo >= this.getCurrentPeriod(), \"Cannot transfer to the past\");\n\n    bool isForward = _periodTo > _periodFrom;\n    uint256 periodDiff = isForward ? _periodTo.sub(_periodFrom): _periodFrom.sub(_periodTo);\n    uint256 warpPrice = getWarpPrice(_amount, periodDiff);\n\n    if (isForward) {\n      balances[INTERESTS_SLOT][msg.sender] = balances[INTERESTS_SLOT][msg.sender].add(warpPrice);\n      externalPool.withdraw(warpPrice, msg.sender);\n    } else {\n      uint256 effectivePrice = warpPrice > balances[INTERESTS_SLOT][msg.sender] ? balances[INTERESTS_SLOT][msg.sender] : warpPrice;\n      balances[INTERESTS_SLOT][msg.sender] = balances[INTERESTS_SLOT][msg.sender].sub(effectivePrice);\n      if (originalAsset == ETHER) {\n        require(msg.value >= warpPrice, \"Not enough ether attached to the transaction\");\n        externalPool.deposit.value(warpPrice)(warpPrice);\n      } else {\n        externalPool.deposit(warpPrice);\n      }\n\n    }\n\n    balances[_periodFrom][msg.sender] = balances[_periodFrom][msg.sender].sub(_amount);\n    balances[_periodTo][msg.sender] = balances[_periodTo][msg.sender].add(_amount);\n\n    emit TransferSingle(msg.sender, msg.sender, msg.sender, _periodTo, _amount);\n  }\n\n  function getCurrentPeriod() external view returns(uint256) {\n    return Calendar.getCurrentMonth();\n  }\n\n\n  function getWarpPrice(uint256 _amount, uint256 _periodDiff) public view returns(uint256) {\n    uint256 formula = MAX_RATE.add(interestRate.mul(_periodDiff).div(12));\n    return _amount.mul(formula).div(MAX_RATE).sub(_amount);\n  }\n\n  /**\n     * @dev Internal function to mint an amount of a token with the given ID\n     * @param to The address that will own the minted token\n     * @param id ID of the token to be minted\n     * @param value Amount of the token to be minted\n     */\n  function _mint(address to, uint256 id, uint256 value) internal {\n    require(to != address(0), \"ERC1155: mint to the zero address\");\n\n    balances[id][to] = value.add(balances[id][to]);\n    emit TransferSingle(msg.sender, address(0), to, id, value);\n  }\n\n\n  /**\n     * @dev Internal function to burn an amount of a token with the given ID\n     * @param owner Account which owns the token to be burnt\n     * @param id ID of the token to be burnt\n     * @param value Amount of the token to be burnt\n     */\n  function _burn(address owner, uint256 id, uint256 value) internal {\n    balances[id][owner] = balances[id][owner].sub(value);\n    emit TransferSingle(msg.sender, owner, address(0), id, value);\n  }\n\n  function spaceTransfer(address _to, uint256 _id, uint256 _value) external {\n    balances[_id][msg.sender] = balances[_id][msg.sender].sub(_value);\n    balances[_id][_to] = balances[_id][_to].add(_value);\n    emit TransferSingle(msg.sender, msg.sender, _to, _id, _value);\n  }\n\n  /**\n      @notice Get the balance of an account's Tokens.\n      @param _owner  The address of the token holder\n      @param _id     ID of the Token\n      @return        The _owner's balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\n    // The balance of any account can be calculated from the Transfer events history.\n    // However, since we need to keep the balances to validate transfer request,\n    // there is no extra cost to also privide a querry function.\n    return balances[_id][_owner];\n  }\n\n  function balancesOfYear(address _owner) external view returns (uint256[] memory) {\n    uint256[] memory balances = new uint256[](12);\n    for(uint i = 0; i < 12; i++) {\n      balances[i] = this.balanceOf(_owner, i);\n    }\n    return balances;\n  }\n\n  function getTotalInterests() external view returns (uint256) {\n    return balances[INTERESTS_SLOT][msg.sender];\n  }\n\n  /**\n      Default payable function to accept money from Lending Pools\n   */\n  function() external payable { }\n\n  //IERC-1155 Functions to be implemented later\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {}\n\n  function setApprovalForAll(address _operator, bool _approved) external {}\n\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {}\n\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external { }\n\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external { }\n\n}\n"
    },
    "erc-1155/contracts/IERC1155.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC165.sol\";\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface IERC1155 /* is ERC165 */ {\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be msg.sender.\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_id` argument MUST be the token type being transferred.\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be msg.sender.\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_ids` argument MUST be the list of tokens being transferred.\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n    /**\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\n    */\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n        @dev MUST emit when the URI is updated for a token ID.\n        URIs are defined in RFC 3986.\n        The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    */\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n\n    /**\n        @notice Get the balance of an account's Tokens.\n        @param _owner  The address of the token holder\n        @param _id     ID of the Token\n        @return        The _owner's balance of the Token type requested\n     */\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param _owners The addresses of the token holders\n        @param _ids    ID of the Tokens\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param _operator  Address to add to the set of authorized operators\n        @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param _owner     The owner of the Tokens\n        @param _operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "erc-1155/contracts/ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface ERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param _interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity >=0.4.21 <0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/MockExternalPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IExternalPool.sol\";\n\n/************\n@title MockExternalPool\n@notice Mock implementation of external lending pool for test purpose\n*/\n\ncontract MockExternalPool is IExternalPool {\n\n  uint256 balance;\n\n  function deposit(uint256 amount) external payable {\n    balance += amount;\n  }\n\n  function withdraw(uint256 amount, address payable beneficiary) external {\n    balance -= amount;\n    beneficiary.transfer(amount);\n  }\n\n  function balanceOf(address account) external view returns(uint256) {\n    return balance;\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}